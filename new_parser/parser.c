/* This file autogenerated by parser_gen.py from Grammar */
#include "hotpy.h"

#include "ast.h"
#include "c_lexer.h"
#include "tokens.h"
#include "parser.h"

#define lookahead(p) ((p)->lookahead ? (p)->lookahead : ((p)->lookahead = next_token((p)->lexer)))
#ifdef NDEBUG
#define consume(p) (p)->lookahead = NULL
#else
#define consume(p) do { assert((p)->lookahead); (p)->lookahead = NULL; } while (0)
#endif
R_AST_alias parse_import_as_name(R_Lexer lexer) {
int LA_KIND;
R_AST_alias _val1;
/* List */
{
R_str _val2;
R_str _val3;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val2 = lexer_token_text(lexer);
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_AS) {
/* List */
 int _val4;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AS) expecting_error(kind_AS, lexer);
_val4 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val3 = lexer_token_text(lexer);
lexer_advance(lexer);
    _val3 = _val3;
} else {
    _val3 = (R_str)NULL;
}
_val1 = alias_for_rule_import_as_name(_val2, _val3);
}
return _val1;
}

R_AST_expr parse_list_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val5;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val6;
R_AST_expr _val7;
int _val8;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LBRACK) expecting_error(kind_LBRACK, lexer);
_val6 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LBRACK */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val7 = parse_testlist_comp(lexer);
} else {
    _val7 = (R_AST_expr)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RBRACK) expecting_error(kind_RBRACK, lexer);
_val8 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RBRACK */
_val5 = expr_for_rule_list_expr(_val7, line, column);
}
return _val5;
}

R_tuple parse_tkwarg(R_Lexer lexer) {
int LA_KIND;
R_tuple _val9;
/* List */
{
int _val10;
R_AST_arg _val11;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOUBLESTAR) expecting_error(kind_DOUBLESTAR, lexer);
_val10 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val11 = parse_targ(lexer);
_val9 = make_tuple(2);
ITEM(_val9, 0) = (R_object)PY_SMALL_INT(_val10);
ITEM(_val9, 1) = (R_object)_val11;
}
return _val9;
}

R_AST_stmt parse_small_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val12;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val12 = parse_expr_stmt(lexer);
} else if (LA_KIND == kind_DEL) {
/* Rule */
_val12 = parse_del_stmt(lexer);
} else if (LA_KIND == kind_PASS) {
/* Rule */
_val12 = parse_pass_stmt(lexer);
} else if ((SET_BREAK_CONTINUE_RAISE_RETURN_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val12 = parse_flow_stmt(lexer);
} else if (LA_KIND == kind_IMPORT || LA_KIND == kind_FROM) {
/* Rule */
_val12 = parse_import_stmt(lexer);
} else if (LA_KIND == kind_GLOBAL) {
/* Rule */
_val12 = parse_global_stmt(lexer);
} else if (LA_KIND == kind_NONLOCAL) {
/* Rule */
_val12 = parse_nonlocal_stmt(lexer);
} else {
/* Rule */
_val12 = parse_assert_stmt(lexer);
}
return _val12;
}

R_AST_operator parse_augassign(R_Lexer lexer) {
int LA_KIND;
R_AST_operator _val13;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_PLUSEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_PLUSEQUAL) expecting_error(kind_PLUSEQUAL, lexer);
{
_val13 = operator_for_rule_PLUSEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_MINUSEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_MINUSEQUAL) expecting_error(kind_MINUSEQUAL, lexer);
{
_val13 = operator_for_rule_MINUSEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_STAREQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STAREQUAL) expecting_error(kind_STAREQUAL, lexer);
{
_val13 = operator_for_rule_STAREQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_SLASHEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_SLASHEQUAL) expecting_error(kind_SLASHEQUAL, lexer);
{
_val13 = operator_for_rule_SLASHEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_PERCENTEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_PERCENTEQUAL) expecting_error(kind_PERCENTEQUAL, lexer);
{
_val13 = operator_for_rule_PERCENTEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_AMPEREQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AMPEREQUAL) expecting_error(kind_AMPEREQUAL, lexer);
{
_val13 = operator_for_rule_AMPEREQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_VBAREQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_VBAREQUAL) expecting_error(kind_VBAREQUAL, lexer);
{
_val13 = operator_for_rule_VBAREQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_CIRCUMFLEXEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_CIRCUMFLEXEQUAL) expecting_error(kind_CIRCUMFLEXEQUAL, lexer);
{
_val13 = operator_for_rule_CIRCUMFLEXEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_LEFTSHIFTEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LEFTSHIFTEQUAL) expecting_error(kind_LEFTSHIFTEQUAL, lexer);
{
_val13 = operator_for_rule_LEFTSHIFTEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_RIGHTSHIFTEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RIGHTSHIFTEQUAL) expecting_error(kind_RIGHTSHIFTEQUAL, lexer);
{
_val13 = operator_for_rule_RIGHTSHIFTEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_DOUBLESTAREQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOUBLESTAREQUAL) expecting_error(kind_DOUBLESTAREQUAL, lexer);
{
_val13 = operator_for_rule_DOUBLESTAREQUAL(LA_KIND);
}
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOUBLESLASHEQUAL) expecting_error(kind_DOUBLESLASHEQUAL, lexer);
{
_val13 = operator_for_rule_DOUBLESLASHEQUAL(LA_KIND);
}
lexer_advance(lexer);
}
return _val13;
}

R_AST_stmt parse_import_from(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val14;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val15;
R_tuple _val16;
int _val17;
R_object _val18;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FROM) expecting_error(kind_FROM, lexer);
_val15 = LA_KIND;
lexer_advance(lexer);
/* Ignoring FROM */
/* Rule */
_val16 = parse_import_source(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IMPORT) expecting_error(kind_IMPORT, lexer);
_val17 = LA_KIND;
lexer_advance(lexer);
/* Ignoring IMPORT */
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_STAR) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STAR) expecting_error(kind_STAR, lexer);
_val18 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
} else if (LA_KIND == kind_LPAREN) {
/* List */
R_object _val19;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LPAREN) expecting_error(kind_LPAREN, lexer);
_val19 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
/* Rule */
_val19 = (R_object)parse_import_as_names(lexer);
    _val18 = _val19;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RPAREN) expecting_error(kind_RPAREN, lexer);
_val19 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
} else {
/* Rule */
_val18 = (R_object)parse_import_as_names(lexer);
}
_val14 = stmt_for_rule_import_from(_val16, _val18, line, column);
}
return _val14;
}

R_list parse_small_stmt_list(R_Lexer lexer) {
int LA_KIND;
R_list _val20;
/* OptionalEnd */
{
R_list _val21 = make_list(4);
R_object _val22;
int dummy;
/* Rule */
_val22 = (R_object)parse_small_stmt(lexer);
list_append(_val21, (R_object)_val22);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_SEMI) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_SEMI) expecting_error(kind_SEMI, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_ASSERT_BREAK_CONTINUE_DEL_ELLIPSIS_FALSE_FLOAT_FROM_GLOBAL_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val23;
/* Rule */
_val23 = (R_object)parse_small_stmt(lexer);
    _val22 = _val23;
    list_append(_val21, (R_object)_val22);
    LA_KIND = lexer_token_kind(lexer);
} else {
    break;
}
}
   _val20 = _val21;
}
return _val20;
}

R_AST_stmt parse_funcdef(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val24;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val25;
R_str _val26;
R_AST_arguments _val27;
R_AST_expr _val28;
int _val29;
R_list _val30;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DEF) expecting_error(kind_DEF, lexer);
_val25 = LA_KIND;
lexer_advance(lexer);
/* Ignoring DEF */
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val26 = lexer_token_text(lexer);
lexer_advance(lexer);
/* Rule */
_val27 = parse_parameters(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_ARROW) {
/* List */
 int _val31;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ARROW) expecting_error(kind_ARROW, lexer);
_val31 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val28 = parse_test(lexer);
    _val28 = _val28;
} else {
    _val28 = (R_AST_expr)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val29 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val30 = parse_suite(lexer);
_val24 = stmt_for_rule_funcdef(_val26, _val27, _val28, _val30, line, column);
}
return _val24;
}

R_AST_stmt parse_try_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val32;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val33;
int _val34;
R_list _val35;
R_tuple _val36;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_TRY) expecting_error(kind_TRY, lexer);
_val33 = LA_KIND;
lexer_advance(lexer);
/* Ignoring TRY */
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val34 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val35 = parse_suite(lexer);
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_EXCEPT) {
/* List */
R_object _val38;
R_tuple _val37 = make_tuple(3);
/* OneOrMany */
{
R_tuple _val40;
R_list _val39 = make_list(4);
/* List */
R_object _val42;
int dummy;
R_tuple _val41 = make_tuple(2);
/* Rule */
_val42 = (R_object)parse_except_clause(lexer);
    ITEM(_val41, 0) = _val42;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val42 = (R_object)parse_suite(lexer);
    ITEM(_val41, 1) = _val42;
_val40 = _val41;
list_append(_val39, (R_object)_val40);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_EXCEPT) {
/* List */
R_object _val44;
int dummy;
R_tuple _val43 = make_tuple(2);
/* Rule */
_val44 = (R_object)parse_except_clause(lexer);
    ITEM(_val43, 0) = _val44;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val44 = (R_object)parse_suite(lexer);
    ITEM(_val43, 1) = _val44;
_val40 = _val43;
    list_append(_val39, (R_object)_val40);
    LA_KIND = lexer_token_kind(lexer);
}
   _val38 = (R_object)_val39;
}
    ITEM(_val37, 0) = _val38;
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_ELSE) {
/* List */
R_object _val45;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELSE) expecting_error(kind_ELSE, lexer);
_val45 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val45 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
/* Rule */
_val45 = (R_object)parse_suite(lexer);
    _val38 = _val45;
} else {
    _val38 = (R_object)NULL;
}
    ITEM(_val37, 1) = _val38;
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FINALLY) {
/* List */
R_object _val47;
int dummy;
R_tuple _val46 = make_tuple(2);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FINALLY) expecting_error(kind_FINALLY, lexer);
_val47 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
    ITEM(_val46, 0) = _val47;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val47 = (R_object)parse_suite(lexer);
    ITEM(_val46, 1) = _val47;
_val38 = (R_object)_val46;
} else {
    _val38 = (R_object)NULL;
}
    ITEM(_val37, 2) = _val38;
_val36 = _val37;
} else {
/* List */
R_object _val49;
int dummy;
R_tuple _val48 = make_tuple(2);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FINALLY) expecting_error(kind_FINALLY, lexer);
_val49 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
    ITEM(_val48, 0) = _val49;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val49 = (R_object)parse_suite(lexer);
    ITEM(_val48, 1) = _val49;
_val36 = _val48;
}
_val32 = stmt_for_rule_try_stmt(_val35, _val36, line, column);
}
return _val32;
}

R_AST_cmpop parse_comp_op(R_Lexer lexer) {
int LA_KIND;
R_AST_cmpop _val50;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_LESS) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LESS) expecting_error(kind_LESS, lexer);
{
_val50 = cmpop_for_rule_LESS(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_GREATER) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_GREATER) expecting_error(kind_GREATER, lexer);
{
_val50 = cmpop_for_rule_GREATER(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_EQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_EQUAL) expecting_error(kind_EQUAL, lexer);
{
_val50 = cmpop_for_rule_EQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_GREATEREQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_GREATEREQUAL) expecting_error(kind_GREATEREQUAL, lexer);
{
_val50 = cmpop_for_rule_GREATEREQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_LESSEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LESSEQUAL) expecting_error(kind_LESSEQUAL, lexer);
{
_val50 = cmpop_for_rule_LESSEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_NOTEQUAL) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NOTEQUAL) expecting_error(kind_NOTEQUAL, lexer);
{
_val50 = cmpop_for_rule_NOTEQUAL(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_IN) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IN) expecting_error(kind_IN, lexer);
{
_val50 = cmpop_for_rule_IN(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_NOT) {
/* Rule */
_val50 = parse_not_in(lexer);
} else {
/* Rule */
_val50 = parse_is(lexer);
}
return _val50;
}

R_AST_arguments parse_parameters(R_Lexer lexer) {
int LA_KIND;
R_AST_arguments _val51;
/* List */
{
int _val52;
R_AST_arguments _val53;
int _val54;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LPAREN) expecting_error(kind_LPAREN, lexer);
_val52 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LPAREN */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_DOUBLESTAR_NAME_STAR[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val53 = parse_typedargslist(lexer);
} else {
    _val53 = (R_AST_arguments)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RPAREN) expecting_error(kind_RPAREN, lexer);
_val54 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RPAREN */
_val51 = _val53;
}
return _val51;
}

R_tuple parse_relative_source(R_Lexer lexer) {
int LA_KIND;
R_tuple _val55;
/* List */
{
R_int _val56;
R_list _val57;
/* Rule */
_val56 = parse_level(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NAME) {
/* Rule */
_val57 = parse_dotted_name(lexer);
} else {
    _val57 = (R_list)NULL;
}
_val55 = make_tuple(2);
ITEM(_val55, 0) = (R_object)_val56;
ITEM(_val55, 1) = (R_object)_val57;
}
return _val55;
}

R_AST_expr parse_exprlist(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val58;
/* OptionalEnd */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_list _val59 = make_list(4);
R_object _val60;
int dummy;
int trailing = 0;
/* Rule */
_val60 = (R_object)parse_star_expr(lexer);
list_append(_val59, (R_object)_val60);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val61;
/* Rule */
_val61 = (R_object)parse_star_expr(lexer);
    _val60 = _val61;
    list_append(_val59, (R_object)_val60);
    LA_KIND = lexer_token_kind(lexer);
} else {
    trailing = 1;
    break;
}
}
_val58 = expr_for_rule_exprlist(_val59, trailing, line, column);
}
return _val58;
}

R_AST_expr parse_bracketted_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val62;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val63;
R_AST_expr _val64;
int _val65;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LPAREN) expecting_error(kind_LPAREN, lexer);
_val63 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LPAREN */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_YIELD) {
/* Rule */
_val64 = parse_yield_expr(lexer);
} else {
/* Rule */
_val64 = parse_testlist_comp(lexer);
}
} else {
    _val64 = (R_AST_expr)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RPAREN) expecting_error(kind_RPAREN, lexer);
_val65 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RPAREN */
_val62 = expr_for_rule_bracketted_expr(_val64, line, column);
}
return _val62;
}

R_tuple parse_targdef(R_Lexer lexer) {
int LA_KIND;
R_tuple _val66;
/* List */
{
R_AST_arg _val67;
R_AST_expr _val68;
/* Rule */
_val67 = parse_targ(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_ASSIGN) {
/* List */
 int _val69;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ASSIGN) expecting_error(kind_ASSIGN, lexer);
_val69 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val68 = parse_test(lexer);
    _val68 = _val68;
} else {
    _val68 = (R_AST_expr)NULL;
}
_val66 = make_tuple(2);
ITEM(_val66, 0) = (R_object)_val67;
ITEM(_val66, 1) = (R_object)_val68;
}
return _val66;
}

R_AST_expr parse_lambdef_nocond(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val70;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val71;
R_AST_arguments _val72;
int _val73;
R_AST_expr _val74;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LAMBDA) expecting_error(kind_LAMBDA, lexer);
_val71 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LAMBDA */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_DOUBLESTAR_NAME_STAR[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val72 = parse_varargslist(lexer);
} else {
    _val72 = (R_AST_arguments)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val73 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val74 = parse_test_nocond(lexer);
_val70 = expr_for_rule_lambdef_nocond(_val72, _val74, line, column);
}
return _val70;
}

R_AST_expr parse_factor(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val75;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_MINUS_PLUS_TILDE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val75 = parse_unary_expr(lexer);
} else {
/* Rule */
_val75 = parse_power(lexer);
}
return _val75;
}

R_list parse_suite(R_Lexer lexer) {
int LA_KIND;
R_list _val76;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ASSERT_BREAK_CONTINUE_DEL_ELLIPSIS_FALSE_FLOAT_FROM_GLOBAL_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val76 = parse_simple_stmt(lexer);
} else {
/* Rule */
_val76 = parse_indented_block(lexer);
}
return _val76;
}

R_AST_expr parse_and_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val77;
/* Binary */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val78;
int _val79;
R_AST_expr _val80;
/* Rule */
_val78 = parse_shift_expr(lexer);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_AMPER) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AMPER) expecting_error(kind_AMPER, lexer);
_val79 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val80 = parse_shift_expr(lexer);
_val78 = expr_for_rule_and_expr(_val78, _val79, _val80, line, column);
     LA_KIND = lexer_token_kind(lexer);
}
   _val77 = _val78;
}
return _val77;
}

R_AST_expr parse_string(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val81;
/* OneOrMany */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_str _val83;
R_list _val82 = make_list(4);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STRING) expecting_error(kind_STRING, lexer);
_val83 = lexer_token_text(lexer);
lexer_advance(lexer);
list_append(_val82, (R_object)_val83);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_STRING) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STRING) expecting_error(kind_STRING, lexer);
_val83 = lexer_token_text(lexer);
lexer_advance(lexer);
    list_append(_val82, (R_object)_val83);
    LA_KIND = lexer_token_kind(lexer);
}
_val81 = expr_for_rule_string(_val82, line, column);
}
return _val81;
}

R_list parse_simple_stmt(R_Lexer lexer) {
int LA_KIND;
R_list _val84;
/* List */
{
R_list _val85;
int _val86;
/* Rule */
_val85 = parse_small_stmt_list(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NEWLINE) expecting_error(kind_NEWLINE, lexer);
_val86 = LA_KIND;
lexer_advance(lexer);
/* Ignoring NEWLINE */
_val84 = _val85;
}
return _val84;
}

R_AST_stmt parse_void(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val87;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NEWLINE) expecting_error(kind_NEWLINE, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val87 = stmt_for_rule_NEWLINE(LA_KIND, line, column);
}
lexer_advance(lexer);
return _val87;
}

R_AST_expr parse_testlist(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val88;
/* OptionalEnd */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_list _val89 = make_list(4);
R_object _val90;
int dummy;
int trailing = 0;
/* Rule */
_val90 = (R_object)parse_test(lexer);
list_append(_val89, (R_object)_val90);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val91;
/* Rule */
_val91 = (R_object)parse_test(lexer);
    _val90 = _val91;
    list_append(_val89, (R_object)_val90);
    LA_KIND = lexer_token_kind(lexer);
} else {
    trailing = 1;
    break;
}
}
_val88 = expr_for_rule_testlist(_val89, trailing, line, column);
}
return _val88;
}

R_AST_stmt parse_classdef(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val92;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val93;
R_str _val94;
R_list _val95;
int _val96;
R_list _val97;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_CLASS) expecting_error(kind_CLASS, lexer);
_val93 = LA_KIND;
lexer_advance(lexer);
/* Ignoring CLASS */
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val94 = lexer_token_text(lexer);
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_LPAREN) {
/* List */
 int _val98;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LPAREN) expecting_error(kind_LPAREN, lexer);
_val98 = LA_KIND;
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_DOUBLESTAR_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val95 = parse_arglist(lexer);
} else {
    _val95 = (R_list)NULL;
}
    _val95 = _val95;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RPAREN) expecting_error(kind_RPAREN, lexer);
_val98 = LA_KIND;
lexer_advance(lexer);
} else {
    _val95 = (R_list)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val96 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val97 = parse_suite(lexer);
_val92 = stmt_for_rule_classdef(_val94, _val95, _val97, line, column);
}
return _val92;
}

R_AST_stmt parse_assert_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val99;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val100;
R_AST_expr _val101;
R_AST_expr _val102;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ASSERT) expecting_error(kind_ASSERT, lexer);
_val100 = LA_KIND;
lexer_advance(lexer);
/* Ignoring ASSERT */
/* Rule */
_val101 = parse_test(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_COMMA) {
/* List */
 int _val103;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
_val103 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val102 = parse_test(lexer);
    _val102 = _val102;
} else {
    _val102 = (R_AST_expr)NULL;
}
_val99 = stmt_for_rule_assert_stmt(_val101, _val102, line, column);
}
return _val99;
}

R_AST_stmt parse_for_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val104;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val105;
R_AST_expr _val106;
int _val107;
R_AST_expr _val108;
int _val109;
R_list _val110;
R_list _val111;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FOR) expecting_error(kind_FOR, lexer);
_val105 = LA_KIND;
lexer_advance(lexer);
/* Ignoring FOR */
/* Rule */
_val106 = parse_exprlist(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IN) expecting_error(kind_IN, lexer);
_val107 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val108 = parse_testlist(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val109 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val110 = parse_suite(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_ELSE) {
/* List */
 int _val112;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELSE) expecting_error(kind_ELSE, lexer);
_val112 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val112 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val111 = parse_suite(lexer);
    _val111 = _val111;
} else {
    _val111 = (R_list)NULL;
}
_val104 = stmt_for_rule_for_stmt(_val106, _val107, _val108, _val110, _val111, line, column);
}
return _val104;
}

R_AST_expr parse_lambdef(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val113;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val114;
R_AST_arguments _val115;
int _val116;
R_AST_expr _val117;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LAMBDA) expecting_error(kind_LAMBDA, lexer);
_val114 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LAMBDA */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_DOUBLESTAR_NAME_STAR[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val115 = parse_varargslist(lexer);
} else {
    _val115 = (R_AST_arguments)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val116 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val117 = parse_test(lexer);
_val113 = expr_for_rule_lambdef(_val115, _val117, line, column);
}
return _val113;
}

R_AST_stmt parse_expr_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val118;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val119;
R_object _val120;
/* Rule */
_val119 = parse_testlist(lexer);
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_AMPEREQUAL_ASSIGN_CIRCUMFLEXEQUAL_DOUBLESLASHEQUAL_DOUBLESTAREQUAL_LEFTSHIFTEQUAL_MINUSEQUAL_PERCENTEQUAL_PLUSEQUAL_RIGHTSHIFTEQUAL_SLASHEQUAL_STAREQUAL_VBAREQUAL[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
if ((SET_AMPEREQUAL_CIRCUMFLEXEQUAL_DOUBLESLASHEQUAL_DOUBLESTAREQUAL_LEFTSHIFTEQUAL_MINUSEQUAL_PERCENTEQUAL_PLUSEQUAL_RIGHTSHIFTEQUAL_SLASHEQUAL_STAREQUAL_VBAREQUAL[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val122;
R_tuple _val121 = make_tuple(2);
/* Rule */
_val122 = (R_object)parse_augassign(lexer);
    ITEM(_val121, 0) = _val122;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_YIELD) {
/* Rule */
_val122 = (R_object)parse_yield_expr(lexer);
} else {
/* Rule */
_val122 = (R_object)parse_testlist(lexer);
}
    ITEM(_val121, 1) = _val122;
_val120 = (R_object)_val121;
} else {
/* ZeroOrMany */
{
R_list _val123 = make_list(4);
R_AST_expr _val124;
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_ASSIGN) {
/* List */
 int _val125;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ASSIGN) expecting_error(kind_ASSIGN, lexer);
_val125 = LA_KIND;
lexer_advance(lexer);
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_YIELD) {
/* Rule */
_val124 = parse_yield_expr(lexer);
} else {
/* Rule */
_val124 = parse_testlist(lexer);
}
    _val124 = _val124;
    list_append(_val123, (R_object)_val124);
    LA_KIND = lexer_token_kind(lexer);
}
   _val120 = (R_object)_val123;
}
}
} else {
    _val120 = (R_object)NULL;
}
_val118 = stmt_for_rule_expr_stmt(_val119, _val120, line, column);
}
return _val118;
}

R_AST_expr parse_decorator(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val126;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val127;
R_list _val128;
R_list _val129;
int _val130;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AT) expecting_error(kind_AT, lexer);
_val127 = LA_KIND;
lexer_advance(lexer);
/* Ignoring AT */
/* Rule */
_val128 = parse_dotted_name(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_LPAREN) {
/* List */
 int _val131;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LPAREN) expecting_error(kind_LPAREN, lexer);
_val131 = LA_KIND;
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_DOUBLESTAR_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val129 = parse_arglist(lexer);
} else {
    _val129 = (R_list)NULL;
}
    _val129 = _val129;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RPAREN) expecting_error(kind_RPAREN, lexer);
_val131 = LA_KIND;
lexer_advance(lexer);
} else {
    _val129 = (R_list)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NEWLINE) expecting_error(kind_NEWLINE, lexer);
_val130 = LA_KIND;
lexer_advance(lexer);
/* Ignoring NEWLINE */
_val126 = expr_for_rule_decorator(_val128, _val129, line, column);
}
return _val126;
}

R_AST_expr parse_term(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val132;
/* Binary */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val133;
R_AST_operator _val134;
R_AST_expr _val135;
/* Rule */
_val133 = parse_factor(lexer);
LA_KIND = lexer_token_kind(lexer);
while ((SET_DOUBLESLASH_PERCENT_SLASH_STAR[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val134 = parse_mult_op(lexer);
/* Rule */
_val135 = parse_factor(lexer);
_val133 = expr_for_rule_term(_val133, _val134, _val135, line, column);
     LA_KIND = lexer_token_kind(lexer);
}
   _val132 = _val133;
}
return _val132;
}

R_AST_operator parse_mult_op(R_Lexer lexer) {
int LA_KIND;
R_AST_operator _val136;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_STAR) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STAR) expecting_error(kind_STAR, lexer);
{
_val136 = operator_for_rule_STAR(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_SLASH) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_SLASH) expecting_error(kind_SLASH, lexer);
{
_val136 = operator_for_rule_SLASH(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_PERCENT) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_PERCENT) expecting_error(kind_PERCENT, lexer);
{
_val136 = operator_for_rule_PERCENT(LA_KIND);
}
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOUBLESLASH) expecting_error(kind_DOUBLESLASH, lexer);
{
_val136 = operator_for_rule_DOUBLESLASH(LA_KIND);
}
lexer_advance(lexer);
}
return _val136;
}

R_tuple parse_vargdef(R_Lexer lexer) {
int LA_KIND;
R_tuple _val137;
/* List */
{
R_str _val138;
R_AST_expr _val139;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val138 = lexer_token_text(lexer);
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_ASSIGN) {
/* List */
 int _val140;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ASSIGN) expecting_error(kind_ASSIGN, lexer);
_val140 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val139 = parse_test(lexer);
    _val139 = _val139;
} else {
    _val139 = (R_AST_expr)NULL;
}
_val137 = make_tuple(2);
ITEM(_val137, 0) = (R_object)_val138;
ITEM(_val137, 1) = (R_object)_val139;
}
return _val137;
}

R_AST_stmt parse_if_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val141;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val142;
R_AST_expr _val143;
int _val144;
R_list _val145;
R_list _val146;
R_list _val147;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IF) expecting_error(kind_IF, lexer);
_val142 = LA_KIND;
lexer_advance(lexer);
/* Ignoring IF */
/* Rule */
_val143 = parse_test(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val144 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val145 = parse_suite(lexer);
/* ZeroOrMany */
{
R_list _val148 = make_list(4);
R_tuple _val149;
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_ELIF) {
/* List */
R_object _val151;
int dummy;
R_tuple _val150 = make_tuple(2);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELIF) expecting_error(kind_ELIF, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val151 = (R_object)parse_test(lexer);
    ITEM(_val150, 0) = _val151;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val151 = (R_object)parse_suite(lexer);
    ITEM(_val150, 1) = _val151;
_val149 = _val150;
    list_append(_val148, (R_object)_val149);
    LA_KIND = lexer_token_kind(lexer);
}
   _val146 = _val148;
}
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_ELSE) {
/* List */
 int _val152;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELSE) expecting_error(kind_ELSE, lexer);
_val152 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val152 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val147 = parse_suite(lexer);
    _val147 = _val147;
} else {
    _val147 = (R_list)NULL;
}
_val141 = stmt_for_rule_if_stmt(_val143, _val145, _val146, _val147, line, column);
}
return _val141;
}

R_int parse_level(R_Lexer lexer) {
int LA_KIND;
R_int _val153;
/* OneOrMany */
{
R_object _val155;
R_list _val154 = make_list(4);
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_DOT) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOT) expecting_error(kind_DOT, lexer);
_val155 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELLIPSIS) expecting_error(kind_ELLIPSIS, lexer);
_val155 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
}
list_append(_val154, (R_object)_val155);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_ELLIPSIS || LA_KIND == kind_DOT) {
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_DOT) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOT) expecting_error(kind_DOT, lexer);
_val155 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELLIPSIS) expecting_error(kind_ELLIPSIS, lexer);
_val155 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
}
    list_append(_val154, (R_object)_val155);
    LA_KIND = lexer_token_kind(lexer);
}
_val153 = int_for_rule_level(_val154);
}
return _val153;
}

R_AST_expr parse_or_test(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val156;
/* SkipList */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_list _val157 = make_list(4);
R_AST_expr _val158;
int _val159;
/* Rule */
_val158 = parse_and_test(lexer);
    list_append(_val157, (R_object)_val158);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_OR) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_OR) expecting_error(kind_OR, lexer);
_val159 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val158 = parse_and_test(lexer);
    list_append(_val157, (R_object)_val158);
    LA_KIND = lexer_token_kind(lexer);
}
_val156 = expr_for_rule_or_test(_val157, line, column);
}
return _val156;
}

R_AST_stmt parse_with_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val160;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val161;
R_AST_expr _val162;
R_AST_expr _val163;
int _val164;
R_list _val165;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_WITH) expecting_error(kind_WITH, lexer);
_val161 = LA_KIND;
lexer_advance(lexer);
/* Ignoring WITH */
/* Rule */
_val162 = parse_test(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_AS) {
/* List */
 int _val166;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AS) expecting_error(kind_AS, lexer);
_val166 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val163 = parse_expr(lexer);
    _val163 = _val163;
} else {
    _val163 = (R_AST_expr)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val164 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val165 = parse_suite(lexer);
_val160 = stmt_for_rule_with_stmt(_val162, _val163, _val165, line, column);
}
return _val160;
}

R_list parse_comp_for(R_Lexer lexer) {
int LA_KIND;
R_list _val167;
/* List */
{
int _val168;
R_AST_expr _val169;
int _val170;
R_AST_expr _val171;
R_tuple _val172;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FOR) expecting_error(kind_FOR, lexer);
_val168 = LA_KIND;
lexer_advance(lexer);
/* Ignoring FOR */
/* Rule */
_val169 = parse_exprlist(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IN) expecting_error(kind_IN, lexer);
_val170 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val171 = parse_or_test(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FOR || LA_KIND == kind_IF) {
/* List */
R_object _val174;
R_tuple _val173 = make_tuple(2);
/* ZeroOrMany */
{
R_list _val175 = make_list(4);
R_AST_expr _val176;
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_IF) {
/* Rule */
_val176 = parse_comp_if(lexer);
    list_append(_val175, (R_object)_val176);
    LA_KIND = lexer_token_kind(lexer);
}
   _val174 = (R_object)_val175;
}
    ITEM(_val173, 0) = _val174;
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FOR) {
/* Rule */
_val174 = (R_object)parse_comp_for(lexer);
} else {
    _val174 = (R_object)NULL;
}
    ITEM(_val173, 1) = _val174;
_val172 = _val173;
} else {
    _val172 = (R_tuple)NULL;
}
_val167 = list_for_rule_comp_for(_val169, _val170, _val171, _val172);
}
return _val167;
}

R_AST_expr parse_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val177;
/* Binary */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val178;
int _val179;
R_AST_expr _val180;
/* Rule */
_val178 = parse_xor_expr(lexer);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_VBAR) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_VBAR) expecting_error(kind_VBAR, lexer);
_val179 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val180 = parse_xor_expr(lexer);
_val178 = expr_for_rule_expr(_val178, _val179, _val180, line, column);
     LA_KIND = lexer_token_kind(lexer);
}
   _val177 = _val178;
}
return _val177;
}

R_tuple parse_import_source(R_Lexer lexer) {
int LA_KIND;
R_tuple _val181;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NAME) {
/* Rule */
_val181 = convert_dotted_name_to_R_tuple(parse_dotted_name(lexer));
} else {
/* Rule */
_val181 = parse_relative_source(lexer);
}
return _val181;
}

R_AST_expr parse_test_nocond(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val182;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val182 = parse_or_test(lexer);
} else {
/* Rule */
_val182 = parse_lambdef_nocond(lexer);
}
return _val182;
}

R_AST_unaryop parse_unary_op(R_Lexer lexer) {
int LA_KIND;
R_AST_unaryop _val183;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_PLUS) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_PLUS) expecting_error(kind_PLUS, lexer);
{
_val183 = unaryop_for_rule_PLUS(LA_KIND);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_MINUS) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_MINUS) expecting_error(kind_MINUS, lexer);
{
_val183 = unaryop_for_rule_MINUS(LA_KIND);
}
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_TILDE) expecting_error(kind_TILDE, lexer);
{
_val183 = unaryop_for_rule_TILDE(lexer_token_text(lexer));
}
lexer_advance(lexer);
}
return _val183;
}

R_object parse_arg(R_Lexer lexer) {
int LA_KIND;
R_object _val184;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val184 = parse_argument(lexer);
} else {
/* Rule */
_val184 = (R_object)parse_kwarg(lexer);
}
return _val184;
}

R_list parse_arglist(R_Lexer lexer) {
int LA_KIND;
R_list _val185;
/* SkipList */
{
R_list _val186 = make_list(4);
R_object _val187;
int _val188;
/* Rule */
_val187 = parse_arg(lexer);
    list_append(_val186, (R_object)_val187);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
_val188 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val187 = parse_arg(lexer);
    list_append(_val186, (R_object)_val187);
    LA_KIND = lexer_token_kind(lexer);
}
   _val185 = _val186;
}
return _val185;
}

R_AST_stmt parse_flow_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val189;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_BREAK) {
/* Rule */
_val189 = parse_break_stmt(lexer);
} else if (LA_KIND == kind_CONTINUE) {
/* Rule */
_val189 = parse_continue_stmt(lexer);
} else if (LA_KIND == kind_RETURN) {
/* Rule */
_val189 = parse_return_stmt(lexer);
} else if (LA_KIND == kind_RAISE) {
/* Rule */
_val189 = parse_raise_stmt(lexer);
} else {
/* Rule */
_val189 = parse_yield_stmt(lexer);
}
return _val189;
}

R_AST_expr parse_index(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val190;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val191;
R_AST_slice _val192;
int _val193;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LBRACK) expecting_error(kind_LBRACK, lexer);
_val191 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LBRACK */
/* Rule */
_val192 = parse_subscriptlist(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RBRACK) expecting_error(kind_RBRACK, lexer);
_val193 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RBRACK */
_val190 = expr_for_rule_index(_val192, line, column);
}
return _val190;
}

R_AST_expr parse_comp_if(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val194;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val195;
R_AST_expr _val196;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IF) expecting_error(kind_IF, lexer);
_val195 = LA_KIND;
lexer_advance(lexer);
/* Ignoring IF */
/* Rule */
_val196 = parse_test_nocond(lexer);
_val194 = expr_for_rule_comp_if(_val196, line, column);
}
return _val194;
}

R_AST_slice parse_slice(R_Lexer lexer) {
int LA_KIND;
R_AST_slice _val197;
/* List */
{
R_AST_expr _val198;
R_AST_slice _val199;
/* Rule */
_val198 = parse_test(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_COLON) {
/* Rule */
_val199 = parse_rslice(lexer);
} else {
    _val199 = (R_AST_slice)NULL;
}
_val197 = slice_for_rule_slice(_val198, _val199);
}
return _val197;
}

R_AST_stmt parse_nonlocal_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val200;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val201;
R_list _val202;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NONLOCAL) expecting_error(kind_NONLOCAL, lexer);
_val201 = LA_KIND;
lexer_advance(lexer);
/* Ignoring NONLOCAL */
/* Rule */
_val202 = parse_name_list(lexer);
_val200 = stmt_for_rule_nonlocal_stmt(_val202, line, column);
}
return _val200;
}

R_AST_expr parse_shift_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val203;
/* Binary */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val204;
int _val205;
R_AST_expr _val206;
/* Rule */
_val204 = parse_arith_expr(lexer);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_LEFTSHIFT || LA_KIND == kind_RIGHTSHIFT) {
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_LEFTSHIFT) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LEFTSHIFT) expecting_error(kind_LEFTSHIFT, lexer);
_val205 = LA_KIND;
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RIGHTSHIFT) expecting_error(kind_RIGHTSHIFT, lexer);
_val205 = LA_KIND;
lexer_advance(lexer);
}
/* Rule */
_val206 = parse_arith_expr(lexer);
_val204 = expr_for_rule_shift_expr(_val204, _val205, _val206, line, column);
     LA_KIND = lexer_token_kind(lexer);
}
   _val203 = _val204;
}
return _val203;
}

R_AST_expr parse_dictorsetmaker(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val207;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val208;
R_object _val209;
/* Rule */
_val208 = parse_test(lexer);
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_COLON_COMMA_FOR[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
if (LA_KIND == kind_COLON) {
/* List */
R_object _val211;
int dummy;
R_tuple _val210 = make_tuple(2);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val211 = (R_object)parse_test(lexer);
    ITEM(_val210, 0) = _val211;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FOR || LA_KIND == kind_COMMA) {
if (LA_KIND == kind_FOR) {
/* Rule */
_val211 = (R_object)parse_comp_for(lexer);
} else {
/* OptionalEnd */
{
R_list _val212 = make_list(4);
R_object _val213;
int dummy;
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val215;
int dummy;
R_tuple _val214 = make_tuple(2);
/* Rule */
_val215 = (R_object)parse_test(lexer);
    ITEM(_val214, 0) = _val215;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val215 = (R_object)parse_test(lexer);
    ITEM(_val214, 1) = _val215;
_val213 = (R_object)_val214;
    list_append(_val212, (R_object)_val213);
    LA_KIND = lexer_token_kind(lexer);
} else {
    break;
}
}
   _val211 = (R_object)_val212;
}
}
} else {
    _val211 = (R_object)NULL;
}
    ITEM(_val210, 1) = _val211;
_val209 = (R_object)_val210;
} else if (LA_KIND == kind_FOR) {
/* Rule */
_val209 = (R_object)parse_comp_for(lexer);
} else {
/* OptionalEnd */
{
R_list _val216 = make_list(4);
R_object _val217;
int dummy;
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val218;
/* Rule */
_val218 = (R_object)parse_test(lexer);
    _val217 = _val218;
    list_append(_val216, (R_object)_val217);
    LA_KIND = lexer_token_kind(lexer);
} else {
    break;
}
}
   _val209 = (R_object)_val216;
}
}
} else {
    _val209 = (R_object)NULL;
}
_val207 = expr_for_rule_dictorsetmaker(_val208, _val209, line, column);
}
return _val207;
}

R_AST_slice parse_subscript(R_Lexer lexer) {
int LA_KIND;
R_AST_slice _val219;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val219 = parse_slice(lexer);
} else {
/* Rule */
_val219 = parse_rslice(lexer);
}
return _val219;
}

R_AST_expr parse_star_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val220;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val221;
R_AST_expr _val222;
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_STAR) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STAR) expecting_error(kind_STAR, lexer);
_val221 = LA_KIND;
lexer_advance(lexer);
} else {
    _val221 = (int)NULL;
}
/* Rule */
_val222 = parse_expr(lexer);
_val220 = expr_for_rule_star_expr(_val221, _val222, line, column);
}
return _val220;
}

R_list parse_decorators(R_Lexer lexer) {
int LA_KIND;
R_list _val223;
/* OneOrMany */
{
R_AST_expr _val225;
R_list _val224 = make_list(4);
/* Rule */
_val225 = parse_decorator(lexer);
list_append(_val224, (R_object)_val225);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_AT) {
/* Rule */
_val225 = parse_decorator(lexer);
    list_append(_val224, (R_object)_val225);
    LA_KIND = lexer_token_kind(lexer);
}
_val223 = _val224;
}
return _val223;
}

R_AST_stmt parse_compound_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val226;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_IF) {
/* Rule */
_val226 = parse_if_stmt(lexer);
} else if (LA_KIND == kind_WHILE) {
/* Rule */
_val226 = parse_while_stmt(lexer);
} else if (LA_KIND == kind_FOR) {
/* Rule */
_val226 = parse_for_stmt(lexer);
} else if (LA_KIND == kind_TRY) {
/* Rule */
_val226 = parse_try_stmt(lexer);
} else if (LA_KIND == kind_WITH) {
/* Rule */
_val226 = parse_with_stmt(lexer);
} else if (LA_KIND == kind_DEF) {
/* Rule */
_val226 = parse_funcdef(lexer);
} else if (LA_KIND == kind_CLASS) {
/* Rule */
_val226 = parse_classdef(lexer);
} else {
/* Rule */
_val226 = parse_decorated(lexer);
}
return _val226;
}

R_list parse_dotted_name(R_Lexer lexer) {
int LA_KIND;
R_list _val227;
/* SkipList */
{
R_list _val228 = make_list(4);
R_str _val229;
int _val230;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val229 = lexer_token_text(lexer);
lexer_advance(lexer);
    list_append(_val228, (R_object)_val229);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_DOT) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOT) expecting_error(kind_DOT, lexer);
_val230 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val229 = lexer_token_text(lexer);
lexer_advance(lexer);
    list_append(_val228, (R_object)_val229);
    LA_KIND = lexer_token_kind(lexer);
}
_val227 = _val228;
}
return _val227;
}

R_AST_expr parse_power(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val231;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val232;
R_tuple _val233;
/* Rule */
_val232 = parse_simple(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_DOUBLESTAR) {
/* List */
R_object _val235;
R_tuple _val234 = make_tuple(2);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOUBLESTAR) expecting_error(kind_DOUBLESTAR, lexer);
_val235 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
    ITEM(_val234, 0) = _val235;
/* Rule */
_val235 = (R_object)parse_factor(lexer);
    ITEM(_val234, 1) = _val235;
_val233 = _val234;
} else {
    _val233 = (R_tuple)NULL;
}
_val231 = expr_for_rule_power(_val232, _val233, line, column);
}
return _val231;
}

R_object parse_stmt(R_Lexer lexer) {
int LA_KIND;
R_object _val236;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ASSERT_BREAK_CONTINUE_DEL_ELLIPSIS_FALSE_FLOAT_FROM_GLOBAL_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val236 = (R_object)parse_simple_stmt(lexer);
} else {
/* Rule */
_val236 = (R_object)parse_compound_stmt(lexer);
}
return _val236;
}

R_AST_stmt parse_import_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val237;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_IMPORT) {
/* Rule */
_val237 = parse_import_name(lexer);
} else {
/* Rule */
_val237 = parse_import_from(lexer);
}
return _val237;
}

R_AST_slice parse_sliceop(R_Lexer lexer) {
int LA_KIND;
R_AST_slice _val238;
/* List */
{
int _val239;
R_AST_expr _val240;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val239 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val240 = parse_test(lexer);
} else {
    _val240 = (R_AST_expr)NULL;
}
_val238 = slice_for_rule_sliceop(_val240);
}
return _val238;
}

R_AST_expr parse_comparison(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val241;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val242;
R_list _val243;
/* Rule */
_val242 = parse_star_expr(lexer);
/* ZeroOrMany */
{
R_list _val244 = make_list(4);
R_tuple _val245;
LA_KIND = lexer_token_kind(lexer);
while ((SET_EQUAL_GREATER_GREATEREQUAL_IN_IS_LESS_LESSEQUAL_NOT_NOTEQUAL[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val247;
R_tuple _val246 = make_tuple(2);
/* Rule */
_val247 = (R_object)parse_comp_op(lexer);
    ITEM(_val246, 0) = _val247;
/* Rule */
_val247 = (R_object)parse_star_expr(lexer);
    ITEM(_val246, 1) = _val247;
_val245 = _val246;
    list_append(_val244, (R_object)_val245);
    LA_KIND = lexer_token_kind(lexer);
}
   _val243 = _val244;
}
_val241 = expr_for_rule_comparison(_val242, _val243, line, column);
}
return _val241;
}

R_AST_stmt parse_pass_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val248;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_PASS) expecting_error(kind_PASS, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val248 = stmt_for_rule_PASS(LA_KIND, line, column);
}
lexer_advance(lexer);
return _val248;
}

R_AST_expr parse_arith_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val249;
/* Binary */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val250;
int _val251;
R_AST_expr _val252;
/* Rule */
_val250 = parse_term(lexer);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_PLUS || LA_KIND == kind_MINUS) {
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_PLUS) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_PLUS) expecting_error(kind_PLUS, lexer);
_val251 = LA_KIND;
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_MINUS) expecting_error(kind_MINUS, lexer);
_val251 = LA_KIND;
lexer_advance(lexer);
}
/* Rule */
_val252 = parse_term(lexer);
_val250 = expr_for_rule_arith_expr(_val250, _val251, _val252, line, column);
     LA_KIND = lexer_token_kind(lexer);
}
   _val249 = _val250;
}
return _val249;
}

R_tuple parse_targlist_item(R_Lexer lexer) {
int LA_KIND;
R_tuple _val253;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NAME) {
/* Rule */
_val253 = parse_targdef(lexer);
} else if (LA_KIND == kind_STAR) {
/* Rule */
_val253 = parse_ttuplearg(lexer);
} else {
/* Rule */
_val253 = parse_tkwarg(lexer);
}
return _val253;
}

R_tuple parse_ttuplearg(R_Lexer lexer) {
int LA_KIND;
R_tuple _val254;
/* List */
{
int _val255;
R_AST_arg _val256;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STAR) expecting_error(kind_STAR, lexer);
_val255 = LA_KIND;
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NAME) {
/* Rule */
_val256 = parse_targ(lexer);
} else {
    _val256 = (R_AST_arg)NULL;
}
_val254 = make_tuple(2);
ITEM(_val254, 0) = (R_object)PY_SMALL_INT(_val255);
ITEM(_val254, 1) = (R_object)_val256;
}
return _val254;
}

R_AST_expr parse_atom(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val257;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_LPAREN) {
/* Rule */
_val257 = parse_bracketted_expr(lexer);
} else if (LA_KIND == kind_LBRACK) {
/* Rule */
_val257 = parse_list_expr(lexer);
} else if (LA_KIND == kind_LCURLY) {
/* Rule */
_val257 = parse_dictorset_expr(lexer);
} else if (LA_KIND == kind_NAME) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val257 = expr_for_rule_NAME(lexer_token_text(lexer), line, column);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_FLOAT) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FLOAT) expecting_error(kind_FLOAT, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val257 = expr_for_rule_FLOAT(lexer_token_text(lexer), line, column);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_INTEGER) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_INTEGER) expecting_error(kind_INTEGER, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val257 = expr_for_rule_INTEGER(lexer_token_text(lexer), line, column);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_STRING) {
/* Rule */
_val257 = parse_string(lexer);
} else if (LA_KIND == kind_ELLIPSIS) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELLIPSIS) expecting_error(kind_ELLIPSIS, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val257 = expr_for_rule_ELLIPSIS(lexer_token_text(lexer), line, column);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_NONE) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NONE) expecting_error(kind_NONE, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val257 = expr_for_rule_NONE(LA_KIND, line, column);
}
lexer_advance(lexer);
} else if (LA_KIND == kind_TRUE) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_TRUE) expecting_error(kind_TRUE, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val257 = expr_for_rule_TRUE(LA_KIND, line, column);
}
lexer_advance(lexer);
} else {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FALSE) expecting_error(kind_FALSE, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val257 = expr_for_rule_FALSE(LA_KIND, line, column);
}
lexer_advance(lexer);
}
return _val257;
}

R_tuple parse_vkwarg(R_Lexer lexer) {
int LA_KIND;
R_tuple _val258;
/* List */
{
int _val259;
R_str _val260;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOUBLESTAR) expecting_error(kind_DOUBLESTAR, lexer);
_val259 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val260 = lexer_token_text(lexer);
lexer_advance(lexer);
_val258 = make_tuple(2);
ITEM(_val258, 0) = (R_object)PY_SMALL_INT(_val259);
ITEM(_val258, 1) = (R_object)_val260;
}
return _val258;
}

R_AST_stmt parse_continue_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val261;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_CONTINUE) expecting_error(kind_CONTINUE, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val261 = stmt_for_rule_CONTINUE(LA_KIND, line, column);
}
lexer_advance(lexer);
return _val261;
}

R_list parse_dotted_as_names(R_Lexer lexer) {
int LA_KIND;
R_list _val262;
/* SkipList */
{
R_list _val263 = make_list(4);
R_AST_alias _val264;
int _val265;
/* Rule */
_val264 = parse_dotted_as_name(lexer);
    list_append(_val263, (R_object)_val264);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
_val265 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val264 = parse_dotted_as_name(lexer);
    list_append(_val263, (R_object)_val264);
    LA_KIND = lexer_token_kind(lexer);
}
   _val262 = _val263;
}
return _val262;
}

R_AST_expr parse_unary_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val266;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_unaryop _val267;
R_AST_expr _val268;
/* Rule */
_val267 = parse_unary_op(lexer);
/* Rule */
_val268 = parse_factor(lexer);
_val266 = expr_for_rule_unary_expr(_val267, _val268, line, column);
}
return _val266;
}

R_AST_expr parse_simple(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val269;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val270;
R_list _val271;
/* Rule */
_val270 = parse_atom(lexer);
/* ZeroOrMany */
{
R_list _val272 = make_list(4);
R_AST_expr _val273;
LA_KIND = lexer_token_kind(lexer);
while ((SET_DOT_LBRACK_LPAREN[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val273 = parse_member(lexer);
    list_append(_val272, (R_object)_val273);
    LA_KIND = lexer_token_kind(lexer);
}
   _val271 = _val272;
}
_val269 = expr_for_rule_simple(_val270, _val271, line, column);
}
return _val269;
}

R_AST_stmt parse_return_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val274;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val275;
R_AST_expr _val276;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RETURN) expecting_error(kind_RETURN, lexer);
_val275 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RETURN */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val276 = parse_testlist(lexer);
} else {
    _val276 = (R_AST_expr)NULL;
}
_val274 = stmt_for_rule_return_stmt(_val276, line, column);
}
return _val274;
}

R_AST_expr parse_testlist_comp(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val277;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val278;
R_list _val279;
/* Rule */
_val278 = parse_test(lexer);
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FOR || LA_KIND == kind_COMMA) {
if (LA_KIND == kind_FOR) {
/* Rule */
_val279 = parse_comp_for(lexer);
} else {
/* OptionalEnd */
{
R_list _val280 = make_list(4);
R_object _val281;
int dummy;
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val282;
/* Rule */
_val282 = (R_object)parse_test(lexer);
    _val281 = _val282;
    list_append(_val280, (R_object)_val281);
    LA_KIND = lexer_token_kind(lexer);
} else {
    break;
}
}
   _val279 = _val280;
}
}
} else {
    _val279 = (R_list)NULL;
}
_val277 = expr_for_rule_testlist_comp(_val278, _val279, line, column);
}
return _val277;
}

R_AST_expr parse_xor_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val283;
/* Binary */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val284;
int _val285;
R_AST_expr _val286;
/* Rule */
_val284 = parse_and_expr(lexer);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_CIRCUMFLEX) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_CIRCUMFLEX) expecting_error(kind_CIRCUMFLEX, lexer);
_val285 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val286 = parse_and_expr(lexer);
_val284 = expr_for_rule_xor_expr(_val284, _val285, _val286, line, column);
     LA_KIND = lexer_token_kind(lexer);
}
   _val283 = _val284;
}
return _val283;
}

R_tuple parse_vararg(R_Lexer lexer) {
int LA_KIND;
R_tuple _val287;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NAME) {
/* Rule */
_val287 = parse_vargdef(lexer);
} else if (LA_KIND == kind_DOUBLESTAR) {
/* Rule */
_val287 = parse_vkwarg(lexer);
} else {
/* Rule */
_val287 = parse_vtuplearg(lexer);
}
return _val287;
}

R_AST_mod parse_single_input(R_Lexer lexer) {
int LA_KIND;
R_AST_mod _val288;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NEWLINE) {
/* Rule */
_val288 = convert_void_to_R_AST_mod(parse_void(lexer));
} else if ((SET_ASSERT_BREAK_CONTINUE_DEL_ELLIPSIS_FALSE_FLOAT_FROM_GLOBAL_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val288 = convert_simple_stmt_to_R_AST_mod(parse_simple_stmt(lexer));
} else {
/* Rule */
_val288 = convert_compound_stmt_to_R_AST_mod(parse_compound_stmt(lexer));
}
return _val288;
}

R_AST_alias parse_dotted_as_name(R_Lexer lexer) {
int LA_KIND;
R_AST_alias _val289;
/* List */
{
R_list _val290;
R_str _val291;
/* Rule */
_val290 = parse_dotted_name(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_AS) {
/* List */
 int _val292;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AS) expecting_error(kind_AS, lexer);
_val292 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val291 = lexer_token_text(lexer);
lexer_advance(lexer);
    _val291 = _val291;
} else {
    _val291 = (R_str)NULL;
}
_val289 = alias_for_rule_dotted_as_name(_val290, _val291);
}
return _val289;
}

R_AST_expr parse_call(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val293;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val294;
R_list _val295;
int _val296;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LPAREN) expecting_error(kind_LPAREN, lexer);
_val294 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LPAREN */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_DOUBLESTAR_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val295 = parse_arglist(lexer);
} else {
    _val295 = (R_list)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RPAREN) expecting_error(kind_RPAREN, lexer);
_val296 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RPAREN */
_val293 = expr_for_rule_call(_val295, line, column);
}
return _val293;
}

R_AST_expr parse_not_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val297;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val298;
R_AST_expr _val299;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NOT) expecting_error(kind_NOT, lexer);
_val298 = LA_KIND;
lexer_advance(lexer);
/* Ignoring NOT */
/* Rule */
_val299 = parse_not_test(lexer);
_val297 = expr_for_rule_not_expr(_val299, line, column);
}
return _val297;
}

R_list parse_import_as_names(R_Lexer lexer) {
int LA_KIND;
R_list _val300;
/* OptionalEnd */
{
R_list _val301 = make_list(4);
R_object _val302;
int dummy;
/* Rule */
_val302 = (R_object)parse_import_as_name(lexer);
list_append(_val301, (R_object)_val302);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NAME) {
/* List */
R_object _val303;
/* Rule */
_val303 = (R_object)parse_import_as_name(lexer);
    _val302 = _val303;
    list_append(_val301, (R_object)_val302);
    LA_KIND = lexer_token_kind(lexer);
} else {
    break;
}
}
   _val300 = _val301;
}
return _val300;
}

R_AST_stmt parse_raise_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val304;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val305;
R_tuple _val306;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RAISE) expecting_error(kind_RAISE, lexer);
_val305 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RAISE */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val308;
R_tuple _val307 = make_tuple(2);
/* Rule */
_val308 = (R_object)parse_test(lexer);
    ITEM(_val307, 0) = _val308;
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FROM) {
/* List */
R_object _val309;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_FROM) expecting_error(kind_FROM, lexer);
_val309 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
/* Rule */
_val309 = (R_object)parse_test(lexer);
    _val308 = _val309;
} else {
    _val308 = (R_object)NULL;
}
    ITEM(_val307, 1) = _val308;
_val306 = _val307;
} else {
    _val306 = (R_tuple)NULL;
}
_val304 = stmt_for_rule_raise_stmt(_val306, line, column);
}
return _val304;
}

R_list parse_indented_block(R_Lexer lexer) {
int LA_KIND;
R_list _val310;
/* List */
{
int _val311;
int _val312;
R_list _val313;
int _val314;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NEWLINE) expecting_error(kind_NEWLINE, lexer);
_val311 = LA_KIND;
lexer_advance(lexer);
/* Ignoring NEWLINE */
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_INDENT) expecting_error(kind_INDENT, lexer);
_val312 = LA_KIND;
lexer_advance(lexer);
/* OneOrMany */
{
R_object _val316;
R_list _val315 = make_list(4);
/* Rule */
_val316 = parse_stmt(lexer);
list_append(_val315, (R_object)_val316);
LA_KIND = lexer_token_kind(lexer);
while ((SET_ASSERT_AT_BREAK_CLASS_CONTINUE_DEF_DEL_ELLIPSIS_FALSE_FLOAT_FOR_FROM_GLOBAL_IF_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_TRY_WHILE_WITH_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val316 = parse_stmt(lexer);
    list_append(_val315, (R_object)_val316);
    LA_KIND = lexer_token_kind(lexer);
}
   _val313 = _val315;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DEDENT) expecting_error(kind_DEDENT, lexer);
_val314 = LA_KIND;
lexer_advance(lexer);
_val310 = list_for_rule_indented_block(_val312, _val313, _val314);
}
return _val310;
}

R_AST_expr parse_attr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val317;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val318;
R_str _val319;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOT) expecting_error(kind_DOT, lexer);
_val318 = LA_KIND;
lexer_advance(lexer);
/* Ignoring DOT */
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val319 = lexer_token_text(lexer);
lexer_advance(lexer);
_val317 = expr_for_rule_attr(_val319, line, column);
}
return _val317;
}

R_AST_mod parse_file_input(R_Lexer lexer) {
int LA_KIND;
R_AST_mod _val320;
/* List */
{
R_list _val321;
int _val322;
/* ZeroOrMany */
{
R_list _val323 = make_list(4);
R_object _val324;
LA_KIND = lexer_token_kind(lexer);
while ((SET_ASSERT_AT_BREAK_CLASS_CONTINUE_DEF_DEL_ELLIPSIS_FALSE_FLOAT_FOR_FROM_GLOBAL_IF_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NEWLINE_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_TRY_WHILE_WITH_YIELD[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NEWLINE) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NEWLINE) expecting_error(kind_NEWLINE, lexer);
_val324 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
} else {
/* Rule */
_val324 = parse_stmt(lexer);
}
    list_append(_val323, (R_object)_val324);
    LA_KIND = lexer_token_kind(lexer);
}
   _val321 = _val323;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ENDMARKER) expecting_error(kind_ENDMARKER, lexer);
_val322 = LA_KIND;
lexer_advance(lexer);
/* Ignoring ENDMARKER */
_val320 = mod_for_rule_file_input(_val321);
}
return _val320;
}

R_AST_slice parse_rslice(R_Lexer lexer) {
int LA_KIND;
R_AST_slice _val325;
/* List */
{
int _val326;
R_AST_expr _val327;
R_AST_slice _val328;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val326 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val327 = parse_test(lexer);
} else {
    _val327 = (R_AST_expr)NULL;
}
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_COLON) {
/* Rule */
_val328 = parse_sliceop(lexer);
} else {
    _val328 = (R_AST_slice)NULL;
}
_val325 = slice_for_rule_rslice(_val327, _val328);
}
return _val325;
}

R_tuple parse_except_clause(R_Lexer lexer) {
int LA_KIND;
R_tuple _val329;
/* List */
{
int _val330;
R_tuple _val331;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_EXCEPT) expecting_error(kind_EXCEPT, lexer);
_val330 = LA_KIND;
lexer_advance(lexer);
/* Ignoring EXCEPT */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val333;
R_tuple _val332 = make_tuple(2);
/* Rule */
_val333 = (R_object)parse_test(lexer);
    ITEM(_val332, 0) = _val333;
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_AS) {
/* List */
R_object _val334;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AS) expecting_error(kind_AS, lexer);
_val334 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val334 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
    _val333 = _val334;
} else {
    _val333 = (R_object)NULL;
}
    ITEM(_val332, 1) = _val333;
_val331 = _val332;
} else {
    _val331 = (R_tuple)NULL;
}
_val329 = make_tuple(1);
ITEM(_val329, 0) = (R_object)_val331;
}
return _val329;
}

R_AST_stmt parse_yield_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val335;
/* Rule */
_val335 = convert_yield_expr_to_R_AST_stmt(parse_yield_expr(lexer));
return _val335;
}

R_AST_cmpop parse_is(R_Lexer lexer) {
int LA_KIND;
R_AST_cmpop _val336;
/* List */
{
int _val337;
int _val338;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IS) expecting_error(kind_IS, lexer);
_val337 = LA_KIND;
lexer_advance(lexer);
/* Ignoring IS */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NOT) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NOT) expecting_error(kind_NOT, lexer);
_val338 = LA_KIND;
lexer_advance(lexer);
} else {
    _val338 = (int)NULL;
}
_val336 = cmpop_for_rule_is(_val338);
}
return _val336;
}

R_object parse_argument(R_Lexer lexer) {
int LA_KIND;
R_object _val339;
/* List */
{
R_AST_expr _val340;
R_object _val341;
/* Rule */
_val340 = parse_test(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FOR || LA_KIND == kind_ASSIGN) {
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_FOR) {
/* Rule */
_val341 = (R_object)parse_comp_for(lexer);
} else {
/* List */
R_object _val342;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ASSIGN) expecting_error(kind_ASSIGN, lexer);
_val342 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
/* Rule */
_val342 = (R_object)parse_test(lexer);
    _val341 = _val342;
}
} else {
    _val341 = (R_object)NULL;
}
_val339 = object_for_rule_argument(_val340, _val341);
}
return _val339;
}

R_tuple parse_kwarg(R_Lexer lexer) {
int LA_KIND;
R_tuple _val343;
/* List */
{
int _val344;
R_AST_expr _val345;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DOUBLESTAR) expecting_error(kind_DOUBLESTAR, lexer);
_val344 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val345 = parse_test(lexer);
_val343 = make_tuple(2);
ITEM(_val343, 0) = (R_object)PY_SMALL_INT(_val344);
ITEM(_val343, 1) = (R_object)_val345;
}
return _val343;
}

R_AST_expr parse_not_test(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val346;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NOT) {
/* Rule */
_val346 = parse_not_expr(lexer);
} else {
/* Rule */
_val346 = parse_comparison(lexer);
}
return _val346;
}

R_AST_arguments parse_typedargslist(R_Lexer lexer) {
int LA_KIND;
R_AST_arguments _val347;
/* SkipList */
{
R_list _val348 = make_list(4);
R_tuple _val349;
int _val350;
/* Rule */
_val349 = parse_targlist_item(lexer);
    list_append(_val348, (R_object)_val349);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
_val350 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val349 = parse_targlist_item(lexer);
    list_append(_val348, (R_object)_val349);
    LA_KIND = lexer_token_kind(lexer);
}
_val347 = arguments_for_rule_typedargslist(_val348);
}
return _val347;
}

R_AST_stmt parse_break_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val351;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_BREAK) expecting_error(kind_BREAK, lexer);
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
_val351 = stmt_for_rule_BREAK(LA_KIND, line, column);
}
lexer_advance(lexer);
return _val351;
}

R_AST_mod parse_eval_input(R_Lexer lexer) {
int LA_KIND;
R_AST_mod _val352;
/* List */
{
R_AST_expr _val353;
R_list _val354;
int _val355;
/* Rule */
_val353 = parse_testlist(lexer);
/* ZeroOrMany */
{
R_list _val356 = make_list(4);
int _val357;
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_NEWLINE) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NEWLINE) expecting_error(kind_NEWLINE, lexer);
_val357 = LA_KIND;
lexer_advance(lexer);
    list_append(_val356, (R_object)PY_SMALL_INT(_val357));
    LA_KIND = lexer_token_kind(lexer);
}
   _val354 = _val356;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ENDMARKER) expecting_error(kind_ENDMARKER, lexer);
_val355 = LA_KIND;
lexer_advance(lexer);
/* Ignoring ENDMARKER */
_val352 = mod_for_rule_eval_input(_val353, _val354);
}
return _val352;
}

R_AST_arg parse_targ(R_Lexer lexer) {
int LA_KIND;
R_AST_arg _val358;
/* List */
{
R_str _val359;
R_AST_expr _val360;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val359 = lexer_token_text(lexer);
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_COLON) {
/* List */
 int _val361;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val361 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val360 = parse_test(lexer);
    _val360 = _val360;
} else {
    _val360 = (R_AST_expr)NULL;
}
_val358 = arg_for_rule_targ(_val359, _val360);
}
return _val358;
}

R_AST_expr parse_member(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val362;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_LPAREN) {
/* Rule */
_val362 = parse_call(lexer);
} else if (LA_KIND == kind_LBRACK) {
/* Rule */
_val362 = parse_index(lexer);
} else {
/* Rule */
_val362 = parse_attr(lexer);
}
return _val362;
}

R_AST_expr parse_test(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val363;
/* Or */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val363 = parse_trinary_expr(lexer);
} else {
/* Rule */
_val363 = parse_lambdef(lexer);
}
return _val363;
}

R_AST_stmt parse_global_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val364;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val365;
R_list _val366;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_GLOBAL) expecting_error(kind_GLOBAL, lexer);
_val365 = LA_KIND;
lexer_advance(lexer);
/* Ignoring GLOBAL */
/* Rule */
_val366 = parse_name_list(lexer);
_val364 = stmt_for_rule_global_stmt(_val366, line, column);
}
return _val364;
}

R_AST_stmt parse_import_name(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val367;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val368;
R_list _val369;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IMPORT) expecting_error(kind_IMPORT, lexer);
_val368 = LA_KIND;
lexer_advance(lexer);
/* Ignoring IMPORT */
/* Rule */
_val369 = parse_dotted_as_names(lexer);
_val367 = stmt_for_rule_import_name(_val369, line, column);
}
return _val367;
}

R_AST_slice parse_subscriptlist(R_Lexer lexer) {
int LA_KIND;
R_AST_slice _val370;
/* OptionalEnd */
{
R_list _val371 = make_list(4);
R_object _val372;
int dummy;
int trailing = 0;
/* Rule */
_val372 = (R_object)parse_subscript(lexer);
list_append(_val371, (R_object)_val372);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_COLON_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val373;
/* Rule */
_val373 = (R_object)parse_subscript(lexer);
    _val372 = _val373;
    list_append(_val371, (R_object)_val372);
    LA_KIND = lexer_token_kind(lexer);
} else {
    trailing = 1;
    break;
}
}
_val370 = slice_for_rule_subscriptlist(_val371, trailing);
}
return _val370;
}

R_AST_expr parse_yield_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val374;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val375;
R_AST_expr _val376;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_YIELD) expecting_error(kind_YIELD, lexer);
_val375 = LA_KIND;
lexer_advance(lexer);
/* Ignoring YIELD */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val376 = parse_testlist(lexer);
} else {
    _val376 = (R_AST_expr)NULL;
}
_val374 = expr_for_rule_yield_expr(_val376, line, column);
}
return _val374;
}

R_AST_expr parse_trinary_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val377;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_AST_expr _val378;
R_tuple _val379;
/* Rule */
_val378 = parse_or_test(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_IF) {
/* List */
R_object _val381;
int dummy;
R_tuple _val380 = make_tuple(2);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IF) expecting_error(kind_IF, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val381 = (R_object)parse_or_test(lexer);
    ITEM(_val380, 0) = _val381;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELSE) expecting_error(kind_ELSE, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val381 = (R_object)parse_test(lexer);
    ITEM(_val380, 1) = _val381;
_val379 = _val380;
} else {
    _val379 = (R_tuple)NULL;
}
_val377 = expr_for_rule_trinary_expr(_val378, _val379, line, column);
}
return _val377;
}

R_list parse_name_list(R_Lexer lexer) {
int LA_KIND;
R_list _val382;
/* SkipList */
{
R_list _val383 = make_list(4);
R_str _val384;
int _val385;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val384 = lexer_token_text(lexer);
lexer_advance(lexer);
    list_append(_val383, (R_object)_val384);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
_val385 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val384 = lexer_token_text(lexer);
lexer_advance(lexer);
    list_append(_val383, (R_object)_val384);
    LA_KIND = lexer_token_kind(lexer);
}
   _val382 = _val383;
}
return _val382;
}

R_AST_expr parse_and_test(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val386;
/* SkipList */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_list _val387 = make_list(4);
R_AST_expr _val388;
int _val389;
/* Rule */
_val388 = parse_not_test(lexer);
    list_append(_val387, (R_object)_val388);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_AND) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_AND) expecting_error(kind_AND, lexer);
_val389 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val388 = parse_not_test(lexer);
    list_append(_val387, (R_object)_val388);
    LA_KIND = lexer_token_kind(lexer);
}
_val386 = expr_for_rule_and_test(_val387, line, column);
}
return _val386;
}

R_AST_expr parse_dictorset_expr(R_Lexer lexer) {
int LA_KIND;
R_AST_expr _val390;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val391;
R_AST_expr _val392;
int _val393;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_LCURLY) expecting_error(kind_LCURLY, lexer);
_val391 = LA_KIND;
lexer_advance(lexer);
/* Ignoring LCURLY */
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* Rule */
_val392 = parse_dictorsetmaker(lexer);
} else {
    _val392 = (R_AST_expr)NULL;
}
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_RCURLY) expecting_error(kind_RCURLY, lexer);
_val393 = LA_KIND;
lexer_advance(lexer);
/* Ignoring RCURLY */
_val390 = expr_for_rule_dictorset_expr(_val392, line, column);
}
return _val390;
}

R_AST_stmt parse_decorated(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val394;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_list _val395;
R_AST_stmt _val396;
/* Rule */
_val395 = parse_decorators(lexer);
/* Or */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_CLASS) {
/* Rule */
_val396 = parse_classdef(lexer);
} else {
/* Rule */
_val396 = parse_funcdef(lexer);
}
_val394 = stmt_for_rule_decorated(_val395, _val396, line, column);
}
return _val394;
}

R_AST_cmpop parse_not_in(R_Lexer lexer) {
int LA_KIND;
R_AST_cmpop _val397;
/* List */
{
int _val398;
int _val399;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NOT) expecting_error(kind_NOT, lexer);
_val398 = LA_KIND;
lexer_advance(lexer);
/* Ignoring NOT */
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_IN) expecting_error(kind_IN, lexer);
_val399 = LA_KIND;
lexer_advance(lexer);
_val397 = cmpop_for_rule_not_in(_val399);
}
return _val397;
}

R_AST_stmt parse_del_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val400;
/* OptionalEnd */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
R_list _val401 = make_list(4);
R_object _val402;
int dummy;
int trailing = 0;
/* List */
R_object _val403;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_DEL) expecting_error(kind_DEL, lexer);
_val403 = (R_object)PY_SMALL_INT(LA_KIND);
lexer_advance(lexer);
/* Rule */
_val403 = (R_object)parse_expr(lexer);
    _val402 = _val403;
list_append(_val401, (R_object)_val402);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
dummy = LA_KIND;
lexer_advance(lexer);
LA_KIND = lexer_token_kind(lexer);
if ((SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_PLUS_STRING_TILDE_TRUE[LA_KIND >> 5] >> (LA_KIND & 31)) & 1) {
/* List */
R_object _val404;
/* Rule */
_val404 = (R_object)parse_expr(lexer);
    _val402 = _val404;
    list_append(_val401, (R_object)_val402);
    LA_KIND = lexer_token_kind(lexer);
} else {
    trailing = 1;
    break;
}
}
_val400 = stmt_for_rule_del_stmt(_val401, trailing, line, column);
}
return _val400;
}

R_AST_stmt parse_while_stmt(R_Lexer lexer) {
int LA_KIND;
R_AST_stmt _val405;
/* List */
{
int line = lexer_getline(lexer);
int column = lexer_getcolumn(lexer);
int _val406;
R_AST_expr _val407;
int _val408;
R_list _val409;
R_list _val410;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_WHILE) expecting_error(kind_WHILE, lexer);
_val406 = LA_KIND;
lexer_advance(lexer);
/* Ignoring WHILE */
/* Rule */
_val407 = parse_test(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val408 = LA_KIND;
lexer_advance(lexer);
/* Ignoring COLON */
/* Rule */
_val409 = parse_suite(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_ELSE) {
/* List */
 int _val411;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_ELSE) expecting_error(kind_ELSE, lexer);
_val411 = LA_KIND;
lexer_advance(lexer);
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COLON) expecting_error(kind_COLON, lexer);
_val411 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val410 = parse_suite(lexer);
    _val410 = _val410;
} else {
    _val410 = (R_list)NULL;
}
_val405 = stmt_for_rule_while_stmt(_val407, _val409, _val410, line, column);
}
return _val405;
}

R_AST_arguments parse_varargslist(R_Lexer lexer) {
int LA_KIND;
R_AST_arguments _val412;
/* SkipList */
{
R_list _val413 = make_list(4);
R_tuple _val414;
int _val415;
/* Rule */
_val414 = parse_vararg(lexer);
    list_append(_val413, (R_object)_val414);
LA_KIND = lexer_token_kind(lexer);
while (LA_KIND == kind_COMMA) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_COMMA) expecting_error(kind_COMMA, lexer);
_val415 = LA_KIND;
lexer_advance(lexer);
/* Rule */
_val414 = parse_vararg(lexer);
    list_append(_val413, (R_object)_val414);
    LA_KIND = lexer_token_kind(lexer);
}
_val412 = arguments_for_rule_varargslist(_val413);
}
return _val412;
}

R_tuple parse_vtuplearg(R_Lexer lexer) {
int LA_KIND;
R_tuple _val416;
/* List */
{
int _val417;
R_str _val418;
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_STAR) expecting_error(kind_STAR, lexer);
_val417 = LA_KIND;
lexer_advance(lexer);
/* ZeroOrOne */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND == kind_NAME) {
/* Token */
LA_KIND = lexer_token_kind(lexer);
if (LA_KIND != kind_NAME) expecting_error(kind_NAME, lexer);
_val418 = lexer_token_text(lexer);
lexer_advance(lexer);
} else {
    _val418 = (R_str)NULL;
}
_val416 = make_tuple(2);
ITEM(_val416, 0) = (R_object)PY_SMALL_INT(_val417);
ITEM(_val416, 1) = (R_object)_val418;
}
return _val416;
}

/* 64 66 72 11 76 2 78 49 84 21 54 23 */
uint32_t SET_AMPEREQUAL_CIRCUMFLEXEQUAL_DOUBLESLASHEQUAL_DOUBLESTAREQUAL_LEFTSHIFTEQUAL_MINUSEQUAL_PERCENTEQUAL_PLUSEQUAL_RIGHTSHIFTEQUAL_SLASHEQUAL_STAREQUAL_VBAREQUAL[] = {
0xa00804,
0x420000,
0x105105,
0x0 };
/* 65 25 33 43 46 47 80 81 52 53 55 57 79 31 */
uint32_t SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_PLUS_STRING_TILDE_TRUE[] = {
0x82000000,
0x2b0c802,
0x38002,
0x0 };
/* 65 67 70 9 77 79 80 81 18 88 25 15 31 33 35 36 6 40 43 45 46 47 52 53 55 57 58 59 62 */
uint32_t SET_ASSERT_BREAK_CONTINUE_DEL_ELLIPSIS_FALSE_FLOAT_FROM_GLOBAL_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_YIELD[] = {
0x82048240,
0x4eb0e91a,
0x103a04a,
0x0 };
/* 6 8 9 12 15 17 18 25 31 33 34 35 36 39 40 43 45 46 47 52 53 55 56 57 58 59 62 65 67 70 77 79 80 81 82 85 86 88 */
uint32_t SET_ASSERT_AT_BREAK_CLASS_CONTINUE_DEF_DEL_ELLIPSIS_FALSE_FLOAT_FOR_FROM_GLOBAL_IF_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NEWLINE_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_TRY_WHILE_WITH_YIELD[] = {
0x82069340,
0x4fb0e99e,
0x167a04a,
0x0 };
/* 19 52 46 */
uint32_t SET_DOT_LBRACK_LPAREN[] = {
0x80000,
0x104000,
0x0,
0x0 };
/* 65 33 57 43 77 46 47 80 81 52 53 55 25 79 31 */
uint32_t SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_PLUS_STAR_STRING_TILDE_TRUE[] = {
0x82000000,
0x2b0c802,
0x3a002,
0x0 };
/* 88 9 67 70 15 */
uint32_t SET_BREAK_CONTINUE_RAISE_RETURN_YIELD[] = {
0x8200,
0x0,
0x1000048,
0x0 };
/* 64 66 7 72 11 76 2 78 49 84 21 54 23 */
uint32_t SET_AMPEREQUAL_ASSIGN_CIRCUMFLEXEQUAL_DOUBLESLASHEQUAL_DOUBLESTAREQUAL_LEFTSHIFTEQUAL_MINUSEQUAL_PERCENTEQUAL_PLUSEQUAL_RIGHTSHIFTEQUAL_SLASHEQUAL_STAREQUAL_VBAREQUAL[] = {
0xa00884,
0x420000,
0x105105,
0x0 };
/* 65 77 79 80 81 88 25 31 33 43 45 46 47 52 53 55 57 59 */
uint32_t SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE_YIELD[] = {
0x82000000,
0xab0e802,
0x103a002,
0x0 };
/* 77 22 55 */
uint32_t SET_DOUBLESTAR_NAME_STAR[] = {
0x400000,
0x800000,
0x2000,
0x0 };
/* 37 38 41 44 60 50 51 59 28 */
uint32_t SET_EQUAL_GREATER_GREATEREQUAL_IN_IS_LESS_LESSEQUAL_NOT_NOTEQUAL[] = {
0x10000000,
0x180c1260,
0x0,
0x0 };
/* 34 13 14 */
uint32_t SET_COLON_COMMA_FOR[] = {
0x6000,
0x4,
0x0,
0x0 };
/* 75 20 77 63 */
uint32_t SET_DOUBLESLASH_PERCENT_SLASH_STAR[] = {
0x100000,
0x80000000,
0x2800,
0x0 };
/* 65 77 79 80 81 25 31 33 43 45 46 47 52 53 55 57 59 */
uint32_t SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[] = {
0x82000000,
0xab0e802,
0x3a002,
0x0 };
/* 80 65 53 */
uint32_t SET_MINUS_PLUS_TILDE[] = {
0x0,
0x200000,
0x10002,
0x0 };
/* 65 13 77 80 81 25 79 31 33 43 45 46 47 52 53 55 57 59 */
uint32_t SET_COLON_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[] = {
0x82002000,
0xab0e802,
0x3a002,
0x0 };
/* 6 8 9 12 15 17 18 25 31 33 34 35 36 39 40 43 45 46 47 52 53 55 57 58 59 62 65 67 70 77 79 80 81 82 85 86 88 */
uint32_t SET_ASSERT_AT_BREAK_CLASS_CONTINUE_DEF_DEL_ELLIPSIS_FALSE_FLOAT_FOR_FROM_GLOBAL_IF_IMPORT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NONLOCAL_NOT_PASS_PLUS_RAISE_RETURN_STAR_STRING_TILDE_TRUE_TRY_WHILE_WITH_YIELD[] = {
0x82069340,
0x4eb0e99e,
0x167a04a,
0x0 };
/* 65 77 79 80 81 22 25 31 33 43 45 46 47 52 53 55 57 59 */
uint32_t SET_DOUBLESTAR_ELLIPSIS_FALSE_FLOAT_INTEGER_LAMBDA_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[] = {
0x82400000,
0xab0e802,
0x3a002,
0x0 };
/* 65 77 79 80 81 25 31 33 43 46 47 52 53 55 57 59 */
uint32_t SET_ELLIPSIS_FALSE_FLOAT_INTEGER_LBRACK_LCURLY_LPAREN_MINUS_NAME_NONE_NOT_PLUS_STAR_STRING_TILDE_TRUE[] = {
0x82000000,
0xab0c802,
0x3a002,
0x0 };
