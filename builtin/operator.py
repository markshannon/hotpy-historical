#This file is automatically generated

@c_function
def make_binary_operator(name:str, func_name:str, rfunc_name:str, fallback):
    pass

@c_function
def make_comparison_operator(name:str, func_name:str, rfunc_name:str, fallback):
    pass

@c_function
def make_operator(name:str, func_name:str, fallback, arity:int):
    pass

@_no_raise
@_pure
@c_function
def is_(a, b):
    pass

@_no_raise
@_pure
@c_function
def is_not(a, b):
    pass

@c_function
def unorderable_types(x, y):
    pass

_eq = make_comparison_operator('eq', '__eq__', '__eq__', is_)

_ne = make_comparison_operator('ne', '__ne__', '__ne__', is_not)

_lt = make_comparison_operator('lt', '__lt__', '__gt__', unorderable_types)

_le = make_comparison_operator('le', '__le__', '__ge__', unorderable_types)

_gt = make_comparison_operator('gt', '__gt__', '__lt__', unorderable_types)

_ge = make_comparison_operator('ge', '__ge__', '__le__', unorderable_types)

@c_function
def no_add(x, y):
    pass

_add = make_binary_operator('add', '__add__', '__radd__', no_add)
del no_add
def add(x, y):
   return x + y
_iadd = make_operator('iadd', '__iadd__', _add, 2)
def iadd(x, y):
   x += y
   return x
@c_function
def no_sub(x, y):
    pass

_sub = make_binary_operator('sub', '__sub__', '__rsub__', no_sub)
del no_sub
def sub(x, y):
   return x - y
_isub = make_operator('isub', '__isub__', _sub, 2)
def isub(x, y):
   x -= y
   return x
@c_function
def no_mul(x, y):
    pass

_mul = make_binary_operator('mul', '__mul__', '__rmul__', no_mul)
del no_mul
def mul(x, y):
   return x * y
_imul = make_operator('imul', '__imul__', _mul, 2)
def imul(x, y):
   x *= y
   return x
@c_function
def no_pow(x, y):
    pass

_pow = make_binary_operator('pow', '__pow__', '__rpow__', no_pow)
del no_pow
def pow(x, y):
   return x ** y
_ipow = make_operator('ipow', '__ipow__', _pow, 2)
def ipow(x, y):
   x **= y
   return x
@c_function
def no_mod(x, y):
    pass

_mod = make_binary_operator('mod', '__mod__', '__rmod__', no_mod)
del no_mod
def mod(x, y):
   return x % y
_imod = make_operator('imod', '__imod__', _mod, 2)
def imod(x, y):
   x %= y
   return x
@c_function
def no_floordiv(x, y):
    pass

_floordiv = make_binary_operator('floordiv', '__floordiv__', '__rfloordiv__', no_floordiv)
del no_floordiv
def floordiv(x, y):
   return x // y
_ifloordiv = make_operator('ifloordiv', '__ifloordiv__', _floordiv, 2)
def ifloordiv(x, y):
   x //= y
   return x
@c_function
def no_truediv(x, y):
    pass

_truediv = make_binary_operator('truediv', '__truediv__', '__rtruediv__', no_truediv)
del no_truediv
def truediv(x, y):
   return x / y
_itruediv = make_operator('itruediv', '__itruediv__', _truediv, 2)
def itruediv(x, y):
   x /= y
   return x
@c_function
def no_and_(x, y):
    pass

_and_ = make_binary_operator('and_', '__and__', '__rand__', no_and_)
del no_and_
def and_(x, y):
   return x & y
_iand = make_operator('iand', '__iand__', _and_, 2)
def iand(x, y):
   x &= y
   return x
@c_function
def no_or_(x, y):
    pass

_or_ = make_binary_operator('or_', '__or__', '__ror__', no_or_)
del no_or_
def or_(x, y):
   return x | y
_ior = make_operator('ior', '__ior__', _or_, 2)
def ior(x, y):
   x |= y
   return x
@c_function
def no_xor(x, y):
    pass

_xor = make_binary_operator('xor', '__xor__', '__rxor__', no_xor)
del no_xor
def xor(x, y):
   return x ^ y
_ixor = make_operator('ixor', '__ixor__', _xor, 2)
def ixor(x, y):
   x ^= y
   return x
@c_function
def no_lshift(x, y):
    pass

_lshift = make_binary_operator('lshift', '__lshift__', '__rlshift__', no_lshift)
del no_lshift
def lshift(x, y):
   return x << y
_ilshift = make_operator('ilshift', '__ilshift__', _lshift, 2)
def ilshift(x, y):
   x <<= y
   return x
@c_function
def no_rshift(x, y):
    pass

_rshift = make_binary_operator('rshift', '__rshift__', '__rrshift__', no_rshift)
del no_rshift
def rshift(x, y):
   return x >> y
_irshift = make_operator('irshift', '__irshift__', _rshift, 2)
def irshift(x, y):
   x >>= y
   return x
def no_getitem(x, y):
    raise TypeError("'%s' object is unsubscriptable" % x$type.__name__)

getitem = make_operator('getitem', '__getitem__', no_getitem, 2)
del no_getitem

def no_setitem(x, y, z):
    raise TypeError("'%s' object does not support item assignment" % x$type.__name__)

setitem = make_operator('setitem', '__setitem__', no_setitem, 3)
del no_setitem

@c_function
def add_binary_behaviour(self:_add$type, f, t = None):
    pass

_add$type.addbehaviour = add_binary_behaviour
del add_binary_behaviour

def behaviour(op):
    return op.addbehaviour


@behaviour(_eq)
@_no_raise
@_pure
@c_function
def eq_int_int(left:int, right:int)->bool:
    pass

@behaviour(_eq)
@_no_raise
@_pure
@c_function
def eq_int_float(left:int, right:float)->bool:
    pass

@behaviour(_eq)
@_no_raise
@_pure
@c_function
def eq_float_int(left:float, right:int)->bool:
    pass

@behaviour(_eq)
@_no_raise
@_pure
@c_function
def eq_float_float(left:float, right:float)->bool:
    pass

@behaviour(_eq)
@_no_raise
@_pure
@c_function
def eq_str_str(left:str, right:str)->bool:
    pass

@behaviour(_ne)
@_no_raise
@_pure
@c_function
def ne_int_int(left:int, right:int)->bool:
    pass

@behaviour(_ne)
@_no_raise
@_pure
@c_function
def ne_int_float(left:int, right:float)->bool:
    pass

@behaviour(_ne)
@_no_raise
@_pure
@c_function
def ne_float_int(left:float, right:int)->bool:
    pass

@behaviour(_ne)
@_no_raise
@_pure
@c_function
def ne_float_float(left:float, right:float)->bool:
    pass

@behaviour(_ne)
@_no_raise
@_pure
@c_function
def ne_str_str(left:str, right:str)->bool:
    pass

@behaviour(_lt)
@_no_raise
@_pure
@c_function
def lt_int_int(left:int, right:int)->bool:
    pass

@behaviour(_lt)
@_no_raise
@_pure
@c_function
def lt_int_float(left:int, right:float)->bool:
    pass

@behaviour(_lt)
@_no_raise
@_pure
@c_function
def lt_float_int(left:float, right:int)->bool:
    pass

@behaviour(_lt)
@_no_raise
@_pure
@c_function
def lt_float_float(left:float, right:float)->bool:
    pass

@behaviour(_lt)
@_no_raise
@_pure
@c_function
def lt_str_str(left:str, right:str)->bool:
    pass

@behaviour(_gt)
@_no_raise
@_pure
@c_function
def gt_int_int(left:int, right:int)->bool:
    pass

@behaviour(_gt)
@_no_raise
@_pure
@c_function
def gt_int_float(left:int, right:float)->bool:
    pass

@behaviour(_gt)
@_no_raise
@_pure
@c_function
def gt_float_int(left:float, right:int)->bool:
    pass

@behaviour(_gt)
@_no_raise
@_pure
@c_function
def gt_float_float(left:float, right:float)->bool:
    pass

@behaviour(_gt)
@_no_raise
@_pure
@c_function
def gt_str_str(left:str, right:str)->bool:
    pass

@behaviour(_le)
@_no_raise
@_pure
@c_function
def le_int_int(left:int, right:int)->bool:
    pass

@behaviour(_le)
@_no_raise
@_pure
@c_function
def le_int_float(left:int, right:float)->bool:
    pass

@behaviour(_le)
@_no_raise
@_pure
@c_function
def le_float_int(left:float, right:int)->bool:
    pass

@behaviour(_le)
@_no_raise
@_pure
@c_function
def le_float_float(left:float, right:float)->bool:
    pass

@behaviour(_le)
@_no_raise
@_pure
@c_function
def le_str_str(left:str, right:str)->bool:
    pass

@behaviour(_ge)
@_no_raise
@_pure
@c_function
def ge_int_int(left:int, right:int)->bool:
    pass

@behaviour(_ge)
@_no_raise
@_pure
@c_function
def ge_int_float(left:int, right:float)->bool:
    pass

@behaviour(_ge)
@_no_raise
@_pure
@c_function
def ge_float_int(left:float, right:int)->bool:
    pass

@behaviour(_ge)
@_no_raise
@_pure
@c_function
def ge_float_float(left:float, right:float)->bool:
    pass

@behaviour(_ge)
@_no_raise
@_pure
@c_function
def ge_str_str(left:str, right:str)->bool:
    pass

#Surrogate functions for operators
@c_function
def tracing_function(op, f):
    pass


_getitem_in_c = False

@method(dict, '__contains__')
@c_function
def dict_contains(d:dict, i)->bool:
    pass

@method(dict_proxy, '__contains__')
@c_function
def dict_proxy_contains(d:dict_proxy, o)->bool:
    pass

del dict_proxy_contains
del dict_contains

def no_delitem(x, y, z):
    raise TypeError("'%s' object does not support item deletion" % x$type.__name__)

delitem = make_operator('delitem', '__delitem__', no_delitem, 3)
del no_delitem

@method(list, '__delitem__')
@_pure
@c_function
def delitem_list(self:list, i:int):
    pass
del delitem_list

@method(str, '__getitem__')
@_pure
@c_function
def getitem_str(self:str, other)->str:
    pass
del getitem_str

@_pure
@c_function
def iadd_list_list(self:list, other:list)->list:
    pass

@method(list, '__iadd__')
def iadd_list(self:list, other)->list:
    if type(other) is list:
        iadd_list_list(self, other)
    else:
        for x in other:
            self.append(x)
    return self
del iadd_list

@method(tuple, '__add__')
@c_function
def tuple_add(self:tuple, other:tuple):
    pass

behaviour(_add)(tuple_add)

del tuple_add

@behaviour(_mul)
@_pure
@c_function
def mul_list_int(self:list, n:int)->list:
     pass

@behaviour(_mul)
@_pure
@c_function
def mul_str_int(self:str, n:int)->str:
     pass

@behaviour(_add)
@_pure
@c_function
def add_list_list(self:list, other:list)->list:
    pass

@method(dict, '__getitem__')
@_pure
@c_function
def getitem_dict(self:dict, i):
    pass
del getitem_dict

#Cannot be pure, as dict could belong to a module.
@method(dict, '__setitem__')
@c_function
def setitem_dict(self:dict, key, value):
    pass
del setitem_dict

@method(dict_proxy, '__getitem__')
@_pure
@c_function
def getitem_dict_proxy(self:dict_proxy, key):
    pass
del getitem_dict_proxy

@method(dict_proxy, '__setitem__')
@c_function
def setitem_dict_proxy(self:dict_proxy, key, value):
    pass
del setitem_dict_proxy

@method(NoneType, '__bool__')
def NoneType_bool(x):
    return False

NoneType.__bool__ = NoneType_bool
NoneType_bool.__name__ = '__bool__'
del NoneType_bool

@method(tuple, '__bool__')
@method(str, '__bool__')
@_no_raise
@_pure
@c_function
def seq_bool(x)->bool:
    pass
seq_bool.__name__ = '__bool__'

del seq_bool

@method(list, '__bool__')
@_no_raise
@_pure
@c_function
def list_bool(l:list)->bool:
    pass
del list_bool

@behaviour(_add)
@_pure
@c_function
def add_str_str(self:str, other:str)->str:
    pass
del add_str_str

@_pure
@c_function
def tuple_getitem_int(self:tuple, index:int):
    pass

@_pure
@c_function
def list_getitem_int(self:list, index:int):
    pass

@_pure
@c_function
def list_getitem_slice(self:list, index:slice)->list:
    pass

@_pure
@c_function
def list_left_slice(self:list, index:int)->list:
    pass

@_pure
@c_function
def list_right_slice(self:list, index:int)->list:
    pass

@_pure
@c_function
def list_reversed(self:list)->list:
    pass

@_pure
@c_function
def list_copy(self:list)->list:
    pass

if _getitem_in_c:

    @method(list, '__getitem__')
    @c_function
    def list_getitem(self:list, index):
        pass

    @method(tuple, '__getitem__')
    @c_function
    def tuple_getitem(self:tuple, index):
        pass

else:

    @method(list, '__getitem__')
    @_no_trace
    @_globals_to_consts
    def list_getitem(self:list, index):
        if index$type is int:
            return list_getitem_int(self, index)
        elif index$type is slice:
            if index.step is None or index.step == 1:
                if index.start is None:
                    if index.stop is None:
                        return list_copy(self)
                    else:
                        return list_left_slice(self, index.stop)
                elif index.stop is None:
                    return list_right_slice(self, index.start)
            elif index.step == -1:
                if index.start is None:
                    if index.stop is None:
                        return list_reversed(self)
                    else:
                        l = list_right_slice(self, index.start+1)
                        list_reverse(l)
                        return l
                elif index.stop is None:
                    l = list_left_slice(self, index.start+1)
                    list_reverse(l)
                    return l
            return list_getitem_slice(self, index)
        elif index?__index__:
            res = index$__index__()
            if not $subtype(res$type, int):
                raise TypeError("__index__ returned non-int type %s)" %
                                type(res).__name__)
            return list_getitem_int(self, res)
        else:
            raise TypeError('list indices must be integers, not %s' %
                            index$type.__name__)

    @method(tuple, '__getitem__')
    #@_no_trace
    #@_globals_to_consts
    def tuple_getitem(self:tuple, index):
        if index$type is int:
            return tuple_getitem_int(self, index)
        elif index$type is slice:
            if index.step is None:
                if index.start is None:
                    if index.stop is None:
                        return self
                    else:
                        return tuple_left_slice(self, index.stop)
                elif index.stop is None:
                    return tuple_right_slice(self, index.start)
            elif index.step == -1:
                if index.start is None:
                    if index.stop is None:
                        return tuple_reversed(self)
                    else:
                        l = tuple_right_slice(self, index.start+1)
                        tuple_reverse(l)
                        return l
                elif index.stop is None:
                    l = tuple_left_slice(self, index.start+1)
                    tuple_reverse(l)
                    return l
            return tuple_getitem_slice(self, index)
        else:
            return tuple_getitem_index(self, index)

del list_getitem

@_pure
@c_function
def list_update(self:list, value:list):
    pass

@c_function
def list_setitem_slice_list_(self:list, index:slice, value:list):
    pass

@_pure
@c_function
def list_left_assign(self:list, index:int, value:list):
    pass

@_pure
@c_function
def list_right_assign(self:list, index:int, value:list):
    pass

@_pure
@c_function
def list_setitem_int(self:list, index:int, value):
    pass

@_no_trace
@_globals_to_consts
def list_setitem_slice_list(self:list, index:slice, value:list):
    if index.step is None:
        if index.start is None:
            if index.stop is None:
                return list_update(self, value)
            else:
                return list_left_assign(self, index.stop, value)
        elif index.stop is None:
            return list_right_assign(self, index.start, value)
    return list_setitem_slice_list_(self, index, value)

@c_function
def list_setitem_slice(self:list, index:slice, value):
    pass

if _getitem_in_c:

    @method(list, '__setitem__')
    @c_function
    def list_setitem(self, index, value):
        pass

else:

    @method(list, '__setitem__')
    @_no_trace
    @_globals_to_consts
    def list_setitem(self, item, value):
        if item$type is int:
            return list_setitem_int(self, item, value)
        elif item$type is slice:
            if type(value) is list:
                return list_setitem_slice_list(self, item, value)
            return list_setitem_slice(self, item, value)
        else:
            if hasattr(item$type, '__index__'):
                item = item$__index__()
                if not $subtype(item$type, int):
                    raise TypeError("__index__ returned non-int type %s)" %
                        type(item).__name__)
                return list_setitem_int(self, item, value)
            else:
                raise TypeError('list indices must be integers, not %s' %
                        type(item).__name__)

del list_setitem

@behaviour(_mod)
@c_function
def mod_str_tuple(s:str, t:tuple):
    pass
del mod_str_tuple

@behaviour(_mod)
def mod(s:str, right:str) :
    return s % (right,)

@behaviour(_mod)
def mod(s:str, b:bool) :
    return s % (b,)

@behaviour(_mod)
def mod(s:str, i:int) :
    return s % (i,)

@behaviour(_mod)
def mod(s:str, f:float) :
    return s % (f,)

def not_(x):
    return not x

@c_function
def make_unary_operator(name:str, func_name:str, fallback:not_$type):
    pass

def no_pos(x):
    raise TypeError("bad operand type for unary +: '%s'" % x$type.__name__)

pos = make_unary_operator("pos", "__pos__", no_pos)

@_globals_to_consts
@_no_trace
def surrogate_pos(x):
    if x?__pos__:
        return x$__pos__()
    else:
        no_pos(x)
tracing_function(pos, surrogate_pos)

del no_pos
def pos(x):
    return +x

def no_neg(x):
    raise TypeError("bad operand type for unary -: '%s'" % x$type.__name__)

neg = make_unary_operator("neg", "__neg__", no_neg)

@_globals_to_consts
@_no_trace
def surrogate_neg(x):
    if x?__neg__:
        return x$__neg__()
    else:
        no_neg(x)
tracing_function(neg, surrogate_neg)

del no_neg
def neg(x):
    return -x

def no_invert(x):
    raise TypeError("bad operand type for unary ~: '%s'" % x$type.__name__)

invert = make_unary_operator("invert", "__invert__", no_invert)

@_globals_to_consts
@_no_trace
def surrogate_invert(x):
    if x?__invert__:
        return x$__invert__()
    else:
        no_invert(x)
tracing_function(invert, surrogate_invert)

del no_invert
def invert(x):
    return ~x

abs = abs

def contains(seq, item):
    return item in seq

@method(list, 'iadd')
def list_extend(self:list, other):
    for i in other:
        self.append(i)
    return self

@method(int, '__index__')
def int_index(self):
    return self

@_no_trace
def index(item)->int:
    res = item$__index__()
    if not $subtype(res$type, int):
        raise TypeError("__index__ returned non-int type %s)" %
                        type(res).__name__)
    return res

def hex(i):
    return index(i)._format(16)

def oct(i):
    return index(i)._format(8)

def bin(i):
    return index(i)._format(2)

del _getitem_in_c

@behaviour(_add)
@_no_raise
@_pure
@c_function
def add_int_int(left:int, right:int)->int:
    pass

@behaviour(_add)
@_no_raise
@_pure
@c_function
def add_int_float(left:int, right:float)->float:
    pass

@behaviour(_add)
@_no_raise
@_pure
@c_function
def add_float_int(left:float, right:int)->float:
    pass

@behaviour(_add)
@_no_raise
@_pure
@c_function
def add_float_float(left:float, right:float)->float:
    pass

@behaviour(_sub)
@_no_raise
@_pure
@c_function
def sub_int_int(left:int, right:int)->int:
    pass

@behaviour(_sub)
@_no_raise
@_pure
@c_function
def sub_int_float(left:int, right:float)->float:
    pass

@behaviour(_sub)
@_no_raise
@_pure
@c_function
def sub_float_int(left:float, right:int)->float:
    pass

@behaviour(_sub)
@_no_raise
@_pure
@c_function
def sub_float_float(left:float, right:float)->float:
    pass

@behaviour(_mul)
@_no_raise
@_pure
@c_function
def mul_int_int(left:int, right:int)->int:
    pass

@behaviour(_mul)
@_no_raise
@_pure
@c_function
def mul_int_float(left:int, right:float)->float:
    pass

@behaviour(_mul)
@_no_raise
@_pure
@c_function
def mul_float_int(left:float, right:int)->float:
    pass

@behaviour(_mul)
@_no_raise
@_pure
@c_function
def mul_float_float(left:float, right:float)->float:
    pass

@behaviour(_pow)
@_pure
@c_function
def pow_int_int(left:int, right:int)->int:
    pass

@behaviour(_pow)
@_pure
@c_function
def pow_int_float(left:int, right:float)->float:
    pass

@behaviour(_pow)
@_pure
@c_function
def pow_float_int(left:float, right:int)->float:
    pass

@behaviour(_pow)
@_pure
@c_function
def pow_float_float(left:float, right:float)->float:
    pass

@behaviour(_mod)
@_pure
@c_function
def mod_int_int(left:int, right:int)->int:
    pass

@behaviour(_mod)
@_pure
@c_function
def mod_int_float(left:int, right:float)->float:
    pass

@behaviour(_mod)
@_pure
@c_function
def mod_float_int(left:float, right:int)->float:
    pass

@behaviour(_mod)
@_pure
@c_function
def mod_float_float(left:float, right:float)->float:
    pass

@behaviour(_floordiv)
@_pure
@c_function
def floordiv_int_int(left:int, right:int)->int:
    pass

@behaviour(_floordiv)
@_pure
@c_function
def floordiv_int_float(left:int, right:float)->float:
    pass

@behaviour(_floordiv)
@_pure
@c_function
def floordiv_float_int(left:float, right:int)->float:
    pass

@behaviour(_floordiv)
@_pure
@c_function
def floordiv_float_float(left:float, right:float)->float:
    pass

@behaviour(_truediv)
@_pure
@c_function
def truediv_int_int(left:int, right:int)->int:
    pass

@behaviour(_truediv)
@_pure
@c_function
def truediv_int_float(left:int, right:float)->float:
    pass

@behaviour(_truediv)
@_pure
@c_function
def truediv_float_int(left:float, right:int)->float:
    pass

@behaviour(_truediv)
@_pure
@c_function
def truediv_float_float(left:float, right:float)->float:
    pass

@behaviour(_and_)
@_no_raise
@_pure
@c_function
def and__bool_bool(left:bool, right:bool)->bool:
    pass

@behaviour(_and_)
@_no_raise
@_pure
@c_function
def and__int_int(left:int, right:int)->int:
    pass

@behaviour(_or_)
@_no_raise
@_pure
@c_function
def or__bool_bool(left:bool, right:bool)->bool:
    pass

@behaviour(_or_)
@_no_raise
@_pure
@c_function
def or__int_int(left:int, right:int)->int:
    pass

@behaviour(_xor)
@_no_raise
@_pure
@c_function
def xor_bool_bool(left:bool, right:bool)->bool:
    pass

@behaviour(_xor)
@_no_raise
@_pure
@c_function
def xor_int_int(left:int, right:int)->int:
    pass

@behaviour(_lshift)
@_pure
@c_function
def lshift_int_int(left:int, right:int)->int:
    pass

@behaviour(_rshift)
@_pure
@c_function
def rshift_int_int(left:int, right:int)->int:
    pass

@_no_raise
@_pure
@c_function
def invert_int(left:int)->int:
    pass
int.__invert__ = invert_int

@_no_raise
@_pure
@c_function
def invert_bool(left:bool)->bool:
    pass
bool.__invert__ = invert_bool

@_no_raise
@_pure
@c_function
def pos_int(left:int)->int:
    pass
int.__pos__ = pos_int

@_no_raise
@_pure
@c_function
def neg_int(left:int)->int:
    pass
int.__neg__ = neg_int

@_no_raise
@_pure
@c_function
def pos_float(left:float)->float:
    pass
float.__pos__ = pos_float

@_no_raise
@_pure
@c_function
def neg_float(left:float)->float:
    pass
float.__neg__ = neg_float


@_globals_to_consts
@_no_trace
def surrogate_inplace_add(self, other):
    if self?__iadd__:
        result = self$__iadd__(other)
        if result is not NotImplemented:
            return result
    return self + other

tracing_function(_iadd, surrogate_inplace_add)
del surrogate_inplace_add


@_globals_to_consts
@_no_trace
def surrogate_add(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__radd__:
            result = op2$__radd__(op1)
            if result is not NotImplemented:
                return result
        if op1?__add__:
            result = op1$__add__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__add__:
            result = op1$__add__(op2)
            if result is not NotImplemented:
                return result
        if op2?__radd__:
            result = op2$__radd__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for +: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_add, surrogate_add)
del surrogate_add



@_globals_to_consts
@_no_trace
def surrogate_inplace_sub(self, other):
    if self?__isub__:
        result = self$__isub__(other)
        if result is not NotImplemented:
            return result
    return self - other

tracing_function(_isub, surrogate_inplace_sub)
del surrogate_inplace_sub


@_globals_to_consts
@_no_trace
def surrogate_sub(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rsub__:
            result = op2$__rsub__(op1)
            if result is not NotImplemented:
                return result
        if op1?__sub__:
            result = op1$__sub__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__sub__:
            result = op1$__sub__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rsub__:
            result = op2$__rsub__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for -: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_sub, surrogate_sub)
del surrogate_sub



@_globals_to_consts
@_no_trace
def surrogate_inplace_mod(self, other):
    if self?__imod__:
        result = self$__imod__(other)
        if result is not NotImplemented:
            return result
    return self % other

tracing_function(_imod, surrogate_inplace_mod)
del surrogate_inplace_mod


@_globals_to_consts
@_no_trace
def surrogate_mod(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rmod__:
            result = op2$__rmod__(op1)
            if result is not NotImplemented:
                return result
        if op1?__mod__:
            result = op1$__mod__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__mod__:
            result = op1$__mod__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rmod__:
            result = op2$__rmod__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for %%: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_mod, surrogate_mod)
del surrogate_mod



@_globals_to_consts
@_no_trace
def surrogate_inplace_mul(self, other):
    if self?__imul__:
        result = self$__imul__(other)
        if result is not NotImplemented:
            return result
    return self * other

tracing_function(_imul, surrogate_inplace_mul)
del surrogate_inplace_mul


@_globals_to_consts
@_no_trace
def surrogate_mul(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rmul__:
            result = op2$__rmul__(op1)
            if result is not NotImplemented:
                return result
        if op1?__mul__:
            result = op1$__mul__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__mul__:
            result = op1$__mul__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rmul__:
            result = op2$__rmul__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for *: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_mul, surrogate_mul)
del surrogate_mul



@_globals_to_consts
@_no_trace
def surrogate_inplace_truediv(self, other):
    if self?__itruediv__:
        result = self$__itruediv__(other)
        if result is not NotImplemented:
            return result
    return self / other

tracing_function(_itruediv, surrogate_inplace_truediv)
del surrogate_inplace_truediv


@_globals_to_consts
@_no_trace
def surrogate_truediv(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rtruediv__:
            result = op2$__rtruediv__(op1)
            if result is not NotImplemented:
                return result
        if op1?__truediv__:
            result = op1$__truediv__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__truediv__:
            result = op1$__truediv__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rtruediv__:
            result = op2$__rtruediv__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for /: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_truediv, surrogate_truediv)
del surrogate_truediv



@_globals_to_consts
@_no_trace
def surrogate_inplace_floordiv(self, other):
    if self?__ifloordiv__:
        result = self$__ifloordiv__(other)
        if result is not NotImplemented:
            return result
    return self // other

tracing_function(_ifloordiv, surrogate_inplace_floordiv)
del surrogate_inplace_floordiv


@_globals_to_consts
@_no_trace
def surrogate_floordiv(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rfloordiv__:
            result = op2$__rfloordiv__(op1)
            if result is not NotImplemented:
                return result
        if op1?__floordiv__:
            result = op1$__floordiv__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__floordiv__:
            result = op1$__floordiv__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rfloordiv__:
            result = op2$__rfloordiv__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for //: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_floordiv, surrogate_floordiv)
del surrogate_floordiv



@_globals_to_consts
@_no_trace
def surrogate_inplace_lshift(self, other):
    if self?__ilshift__:
        result = self$__ilshift__(other)
        if result is not NotImplemented:
            return result
    return self << other

tracing_function(_ilshift, surrogate_inplace_lshift)
del surrogate_inplace_lshift


@_globals_to_consts
@_no_trace
def surrogate_lshift(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rlshift__:
            result = op2$__rlshift__(op1)
            if result is not NotImplemented:
                return result
        if op1?__lshift__:
            result = op1$__lshift__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__lshift__:
            result = op1$__lshift__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rlshift__:
            result = op2$__rlshift__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for <<: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_lshift, surrogate_lshift)
del surrogate_lshift



@_globals_to_consts
@_no_trace
def surrogate_inplace_rshift(self, other):
    if self?__irshift__:
        result = self$__irshift__(other)
        if result is not NotImplemented:
            return result
    return self >> other

tracing_function(_irshift, surrogate_inplace_rshift)
del surrogate_inplace_rshift


@_globals_to_consts
@_no_trace
def surrogate_rshift(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rrshift__:
            result = op2$__rrshift__(op1)
            if result is not NotImplemented:
                return result
        if op1?__rshift__:
            result = op1$__rshift__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__rshift__:
            result = op1$__rshift__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rrshift__:
            result = op2$__rrshift__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for >>: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_rshift, surrogate_rshift)
del surrogate_rshift



@_globals_to_consts
@_no_trace
def surrogate_inplace_pow(self, other):
    if self?__ipow__:
        result = self$__ipow__(other)
        if result is not NotImplemented:
            return result
    return self ** other

tracing_function(_ipow, surrogate_inplace_pow)
del surrogate_inplace_pow


@_globals_to_consts
@_no_trace
def surrogate_pow(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rpow__:
            result = op2$__rpow__(op1)
            if result is not NotImplemented:
                return result
        if op1?__pow__:
            result = op1$__pow__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__pow__:
            result = op1$__pow__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rpow__:
            result = op2$__rpow__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for **: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_pow, surrogate_pow)
del surrogate_pow



@_globals_to_consts
@_no_trace
def surrogate_inplace_and(self, other):
    if self?__iand__:
        result = self$__iand__(other)
        if result is not NotImplemented:
            return result
    return self & other

tracing_function(_iand, surrogate_inplace_and)
del surrogate_inplace_and


@_globals_to_consts
@_no_trace
def surrogate_and(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rand__:
            result = op2$__rand__(op1)
            if result is not NotImplemented:
                return result
        if op1?__and__:
            result = op1$__and__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__and__:
            result = op1$__and__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rand__:
            result = op2$__rand__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for &: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_and_, surrogate_and)
del surrogate_and



@_globals_to_consts
@_no_trace
def surrogate_inplace_or(self, other):
    if self?__ior__:
        result = self$__ior__(other)
        if result is not NotImplemented:
            return result
    return self | other

tracing_function(_ior, surrogate_inplace_or)
del surrogate_inplace_or


@_globals_to_consts
@_no_trace
def surrogate_or(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__ror__:
            result = op2$__ror__(op1)
            if result is not NotImplemented:
                return result
        if op1?__or__:
            result = op1$__or__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__or__:
            result = op1$__or__(op2)
            if result is not NotImplemented:
                return result
        if op2?__ror__:
            result = op2$__ror__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for |: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_or_, surrogate_or)
del surrogate_or



@_globals_to_consts
@_no_trace
def surrogate_inplace_xor(self, other):
    if self?__ixor__:
        result = self$__ixor__(other)
        if result is not NotImplemented:
            return result
    return self ^ other

tracing_function(_ixor, surrogate_inplace_xor)
del surrogate_inplace_xor


@_globals_to_consts
@_no_trace
def surrogate_xor(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__rxor__:
            result = op2$__rxor__(op1)
            if result is not NotImplemented:
                return result
        if op1?__xor__:
            result = op1$__xor__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__xor__:
            result = op1$__xor__(op2)
            if result is not NotImplemented:
                return result
        if op2?__rxor__:
            result = op2$__rxor__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unsupported operand type(s) for ^: '%s' and '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_xor, surrogate_xor)
del surrogate_xor



@_globals_to_consts
@_no_trace
def surrogate_eq(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__eq__:
            result = op2$__eq__(op1)
            if result is not NotImplemented:
                return result
        if op1?__eq__:
            result = op1$__eq__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__eq__:
            result = op1$__eq__(op2)
            if result is not NotImplemented:
                return result
        if op2?__eq__:
            result = op2$__eq__(op1)
            if result is not NotImplemented:
                return result
    return op1 is op2;

tracing_function(_eq, surrogate_eq)
del surrogate_eq



@_globals_to_consts
@_no_trace
def surrogate_ne(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__ne__:
            result = op2$__ne__(op1)
            if result is not NotImplemented:
                return result
        if op1?__ne__:
            result = op1$__ne__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__ne__:
            result = op1$__ne__(op2)
            if result is not NotImplemented:
                return result
        if op2?__ne__:
            result = op2$__ne__(op1)
            if result is not NotImplemented:
                return result
    return op1 is not op2;

tracing_function(_ne, surrogate_ne)
del surrogate_ne



@_globals_to_consts
@_no_trace
def surrogate_lt(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__gt__:
            result = op2$__gt__(op1)
            if result is not NotImplemented:
                return result
        if op1?__lt__:
            result = op1$__lt__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__lt__:
            result = op1$__lt__(op2)
            if result is not NotImplemented:
                return result
        if op2?__gt__:
            result = op2$__gt__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unorderable type(s): '%s' < '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_lt, surrogate_lt)
del surrogate_lt



@_globals_to_consts
@_no_trace
def surrogate_gt(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__lt__:
            result = op2$__lt__(op1)
            if result is not NotImplemented:
                return result
        if op1?__gt__:
            result = op1$__gt__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__gt__:
            result = op1$__gt__(op2)
            if result is not NotImplemented:
                return result
        if op2?__lt__:
            result = op2$__lt__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unorderable type(s): '%s' > '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_gt, surrogate_gt)
del surrogate_gt



@_globals_to_consts
@_no_trace
def surrogate_le(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__ge__:
            result = op2$__ge__(op1)
            if result is not NotImplemented:
                return result
        if op1?__le__:
            result = op1$__le__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__le__:
            result = op1$__le__(op2)
            if result is not NotImplemented:
                return result
        if op2?__ge__:
            result = op2$__ge__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unorderable type(s): '%s' <= '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_le, surrogate_le)
del surrogate_le



@_globals_to_consts
@_no_trace
def surrogate_ge(op1, op2):
    t1 = op1$type
    t2 = op2$type
    if t1 is not t2 and $subtype(t1, t2):
        if op2?__le__:
            result = op2$__le__(op1)
            if result is not NotImplemented:
                return result
        if op1?__ge__:
            result = op1$__ge__(op2)
            if result is not NotImplemented:
                return result
    else:
        if op1?__ge__:
            result = op1$__ge__(op2)
            if result is not NotImplemented:
                return result
        if op2?__le__:
            result = op2$__le__(op1)
            if result is not NotImplemented:
                return result
    raise TypeError("unorderable type(s): '%s' >= '%s'" %
                    (t1$__name__, t2$__name__))

tracing_function(_ge, surrogate_ge)
del surrogate_ge


del tracing_function
